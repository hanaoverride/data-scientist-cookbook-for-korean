# 2. 인터넷과 HTTP 🌐

## 목차
- [2. 인터넷과 HTTP 🌐](#2-인터넷과-http-)
  - [목차](#목차)
  - [인터넷의 핵심 프로토콜: TCP/IP](#인터넷의-핵심-프로토콜-tcpip)
    - [TCP/IP 4계층 모델](#tcpip-4계층-모델)
    - [데이터 전송 과정: 캡슐화와 역캡슐화](#데이터-전송-과정-캡슐화와-역캡슐화)
  - [웹 통신의 언어: HTTP](#웹-통신의-언어-http)
    - [HTTP 메시지 구조](#http-메시지-구조)
    - [HTTP 메서드: 서버에 무엇을 원하는가?](#http-메서드-서버에-무엇을-원하는가)
    - [HTTP의 특징: 무상태(Stateless)와 쿠키/세션](#http의-특징-무상태stateless와-쿠키세션)
  - [HTTP 상태 코드: 서버의 응답](#http-상태-코드-서버의-응답)
  - [웹 보안 정책: CORS](#웹-보안-정책-cors)

---

## 인터넷의 핵심 프로토콜: TCP/IP

인터넷은 **TCP/IP**라는 핵심 프로토콜 스위트(집합) 위에서 동작합니다. 이 둘은 인터넷 통신에서 각기 다른 중요한 역할을 담당합니다.

- **IP (Internet Protocol)** : 데이터 조각(패킷)에 목적지 **IP 주소**를 붙여 해당 컴퓨터까지 데이터를 **전달하는 역할**을 합니다. 하지만 전송 순서나 데이터 손상 여부는 보장하지 않습니다. (일반 우편과 유사)
- **TCP (Transmission Control Protocol)** : IP 위에서 동작하며, 데이터가 **순서대로, 빠짐없이, 안전하게** 도착했는지 확인하고 제어하는 역할을 합니다. 3-way 핸드셰이크라는 과정을 통해 연결을 설정하고, 데이터의 흐름을 조절하며 신뢰성 있는 통신을 보장합니다. (등기 우편과 유사)

### TCP/IP 4계층 모델

TCP/IP 모델은 실제 인터넷 통신 과정을 4개의 계층으로 나누어 설명합니다.

| 계층 | 주요 역할 | 대표 프로토콜 | 데이터 단위 |
|---|---|---|---|
| 4. **응용 계층** | 사용자와 직접 상호작용하는 서비스 제공 | **HTTP**, FTP, SMTP, DNS | 데이터 |
| 3. **전송 계층** | **종단 간(End-to-end)**  신뢰성 있는 데이터 전송 및 포트 번호 지정 | **TCP**, UDP | 세그먼트 |
| 2. **인터넷 계층** | **경로 설정(Routing)**  및 IP 주소 지정 | **IP**, ICMP | 패킷 |
| 1. **네트워크 인터페이스** | 물리적인 네트워크를 통해 실제 데이터(0과 1) 전송 | Ethernet, Wi-Fi | 프레임 |

### 데이터 전송 과정: 캡슐화와 역캡슐화

데이터를 보낼 때, 각 계층은 자신의 역할에 필요한 정보(헤더)를 데이터에 덧붙입니다. 이 과정을 **캡슐화(Encapsulation)** 라고 합니다.

`데이터` -> `[TCP 헤더 + 데이터]` -> `[IP 헤더 + TCP 헤더 + 데이터]` -> `[이더넷 헤더 + ... + 이더넷 트레일러]`

- **응용 계층**: HTTP 데이터 생성
- **전송 계층**: **포트 번호**가 담긴 TCP 헤더 추가
- **인터넷 계층**: **IP 주소**가 담긴 IP 헤더 추가
- **네트워크 인터페이스 계층**: **MAC 주소**가 담긴 이더넷 헤더 추가

데이터를 받는 쪽에서는 이 과정을 역순으로 거치며 헤더를 하나씩 제거하여 원본 데이터를 얻습니다. 이를 **역캡슐화(Decapsulation)**  라고 합니다.

---

## 웹 통신의 언어: HTTP

**HTTP(HyperText Transfer Protocol)**  는 웹 브라우저(클라이언트)와 웹 서버가 서로 데이터를 주고받기 위해 사용하는 핵심적인 응용 계층 프로토콜입니다.

### HTTP 메시지 구조

HTTP 통신은 클라이언트의 **요청(Request)**  과 서버의 **응답(Response)**  메시지로 이루어집니다.

```
# 요청 메시지 예시
GET /index.html HTTP/1.1       ← 시작줄 (메서드, 경로, 버전)
Host: www.example.com          ← 헤더 (부가 정보)
User-Agent: Chrome/108.0
                               ← 빈 줄 (헤더와 본문 구분)
(POST의 경우 요청 본문)          ← 본문 (실제 데이터)
```

### HTTP 메서드: 서버에 무엇을 원하는가?

| 메서드 | 목적 | 특징 |
|---|---|---|
| **GET** | **조회(Read)**  | 서버의 리소스를 요청. URL에 데이터가 노출될 수 있음. |
| **POST** | **생성(Create)**  | 서버에 새로운 리소스를 생성. 데이터는 본문에 담겨 전송됨. |
| **PUT** | **수정(Update)**  | 리소스 전체를 교체. |
| **PATCH** | **수정(Update)**  | 리소스의 일부만 수정. |
| **DELETE** | **삭제(Delete)**  | 지정된 리소스를 삭제. |

### HTTP의 특징: 무상태(Stateless)와 쿠키/세션

HTTP는 **무상태(Stateless)**  프로토콜입니다. 즉, 서버는 이전 요청에 대한 정보를 전혀 기억하지 않습니다. 모든 요청은 독립적인 트랜잭션으로 취급됩니다.

- **문제점**: 상태를 기억하지 못하면, 사용자가 페이지를 이동할 때마다 로그인을 다시 해야 하는 등 서비스를 정상적으로 이용할 수 없습니다.
- **해결책**: **쿠키(Cookie)와 세션(Session)**  을 사용하여 상태를 유지합니다.
    1.  사용자가 로그인하면, 서버는 고유한 **세션 ID**를 생성하여 서버에 저장하고, 이 세션 ID를 **쿠키**에 담아 클라이언트(브라우저)에 보냅니다.
    2.  클라이언트는 이후 모든 요청에 이 쿠키를 함께 보내고, 서버는 쿠키 안의 세션 ID를 보고 사용자를 식별하여 로그인 상태를 유지합니다.

---

## HTTP 상태 코드: 서버의 응답

서버는 클라이언트의 요청에 대해 세 자리 숫자로 된 **상태 코드**로 응답합니다. 이 코드를 통해 요청이 성공했는지, 실패했다면 그 원인이 무엇인지 알 수 있습니다.

| 코드 그룹 | 의미 | 대표적인 코드 |
|---|---|---|
| **2xx (Success)**  | 요청 성공 | `200 OK` (성공), `201 Created` (새 리소스 생성 성공) |
| **3xx (Redirection)**  | 추가 조치 필요 (다른 주소로 이동) | `301 Moved Permanently` (영구 이동), `302 Found` (임시 이동) |
| **4xx (Client Error)**  | 클라이언트 측 오류 | `400 Bad Request` (요청 오류), `401 Unauthorized` (인증 필요), `403 Forbidden` (접근 권한 없음), **`404 Not Found` (페이지 없음)**  |
| **5xx (Server Error)**  | 서버 측 오류 | **`500 Internal Server Error`** (서버 내부 로직 오류), `503 Service Unavailable` (서버 과부하 또는 점검) |


> **서버 보안 관점에서의 상태 코드 활용**
> 
> 일부 서버는 보안을 위해 의도적으로 HTTP 상태 코드를 숨기거나 변조하기도 합니다. 예를 들어:
> - 존재하지 않는 사용자에게 로그인을 시도했을 때, `404 Not Found` 대신 `401 Unauthorized`를 반환하여 계정 존재 여부를 숨김
> - 권한이 없는 리소스에 접근했을 때, `403 Forbidden` 대신 `404 Not Found`를 반환하여 해당 리소스의 존재 자체를 숨김
> - 서버 내부 오류 정보 노출을 방지하기 위해 모든 서버 에러를 `500 Internal Server Error`로 통일
> 
> 이러한 방식은 **보안을 통한 모호성(Security through Obscurity)** 원칙에 따른 것으로, 공격자가 시스템 구조를 파악하기 어렵게 만듭니다.

---

## 웹 보안 정책: CORS

브라우저는 보안을 위해 **동일 출처 정책(Same-Origin Policy, SOP)**  을 따릅니다. 이는 스크립트가 자신이 로드된 출처(프로토콜, 호스트, 포트가 모두 동일)와 다른 출처의 리소스와 상호작용하는 것을 제한하는 정책입니다.

하지만 현대 웹에서는 다른 출처의 API를 호출하는 일이 빈번합니다. 이를 안전하게 허용하기 위한 메커니즘이 **CORS(Cross-Origin Resource Sharing)**  입니다.

- **작동 원리**: 다른 출처로 API를 요청할 때, 브라우저는 먼저 서버에 **"이 출처에서 보내는 요청을 허용하십니까?"**  라고 묻는 예비 요청(Preflight request, `OPTIONS` 메서드 사용)을 보냅니다.
- **서버의 역할**: 서버는 응답 헤더에 `Access-Control-Allow-Origin: https://allowed-site.com` 과 같이 허용할 출처를 명시해주어야 합니다. 이 헤더가 없거나 출처가 일치하지 않으면, 브라우저는 보안 정책 위반으로 간주하고 서버의 응답을 폐기합니다.

> **CORS 에러는 클라이언트의 잘못이 아닙니다.** CORS 에러가 발생했다면, 그것은 브라우저가 보안 정책을 잘 지키고 있다는 의미이며, 문제를 해결해야 하는 곳은 **서버**입니다.