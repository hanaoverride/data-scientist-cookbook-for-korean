# 4. 웹 보안과 인증 🔒

## 목차
- [4. 웹 보안과 인증 🔒](#4-웹-보안과-인증-)
  - [목차](#목차)
  - [인증과 인가: 당신은 누구이며, 무엇을 할 수 있는가?](#인증과-인가-당신은-누구이며-무엇을-할-수-있는가)
  - [비밀번호 저장의 기본: 해시, 솔트, 키 스트레칭](#비밀번호-저장의-기본-해시-솔트-키-스트레칭)
  - [상태 유지 기술: 쿠키, 세션, 토큰](#상태-유지-기술-쿠키-세션-토큰)
    - [쿠키 (Cookie): 브라우저에 저장하는 작은 데이터](#쿠키-cookie-브라우저에-저장하는-작은-데이터)
    - [세션 (Session): 서버에 저장하는 사용자 정보](#세션-session-서버에-저장하는-사용자-정보)
    - [토큰 기반 인증 (JWT): 상태 없는 인증 방식](#토큰-기반-인증-jwt-상태-없는-인증-방식)
  - [성능 최적화와 캐시](#성능-최적화와-캐시)

---

## 인증과 인가: 당신은 누구이며, 무엇을 할 수 있는가?

웹 보안의 시작은 사용자를 확인하고 권한을 제어하는 것입니다.

| 구분 | 인증 (Authentication) | 인가 (Authorization) |
|---|---|---|
| **핵심 질문** | **"당신은 누구입니까?"**  | **"당신은 무엇을 할 수 있습니까?"**  |
| **과정** | 사용자가 제시한 신원 정보(ID/비밀번호, 생체 정보 등)가 시스템에 등록된 정보와 일치하는지 **확인**하는 절차. | 인증된 사용자가 특정 리소스(게시글, 관리자 페이지 등)에 접근하거나 특정 동작(쓰기, 삭제 등)을 수행할 **권한**이 있는지 **검사**하는 절차. |
| **순서** | 항상 인가보다 먼저 수행됩니다. | 반드시 인증 이후에 수행됩니다. |

> **어원으로 이해하는 인증과 인가**
> 
> **한국어 어원 분석**
> - **인증(認證)**: 認(인정할 인) + 證(증명할 증) = "인정하여 증명함"
> - **인가(認可)**: 認(인정할 인) + 可(옳을 가) = "인정하여 허가함"
> 
> **영어 어원 분석**
> - **Authentication**: `authentic` (진짜의, 진정한) + `-ation` (과정, 행위)
>   - 라틴어 `authenticus` (권위 있는, 진정한)에서 유래
>   - **의미**: "진짜임을 증명하는 과정" → **"당신이 누구인지 확인"**
> 
> - **Authorization**: `author` (권한자, 저자) + `-ization` (화시키는 과정)
>   - 라틴어 `auctor` (창조자, 권한자)에서 유래
>   - **의미**: "권한을 부여하는 과정" → **"당신이 무엇을 할 수 있는지 허가"**
> 
> **쉬운 기억법**
> 1. **인증**: "진짜(authentic) 본인이 맞나요?" - 신분증 확인하는 것
> 2. **인가**: "저자(author)처럼 권한이 있나요?" - 출입권한 확인하는 것
> 
> 💡 **순서**: 진짜 확인(인증) → 권한 부여(인가) 순으로 기억하세요!

## 비밀번호 저장의 기본: 해시, 솔트, 키 스트레칭

사용자의 비밀번호를 데이터베이스에 원문 그대로 저장하는 것은 최악의 보안 사고로 이어집니다. 비밀번호는 반드시 **단방향 암호화** 과정을 거쳐 저장해야 합니다.

1.  **해시 (Hash)** : 임의의 길이 데이터를 고정된 길이의 문자열로 변환하는 단방향 함수. 원본 값을 복원하는 것이 불가능해야 합니다.
2.  **솔트 (Salt)** : 해싱 이전에 원본 비밀번호에 임의의 문자열(솔트)을 추가하는 기법입니다. 이를 통해 동일한 비밀번호를 사용하더라도 사용자마다 다른 해시값이 저장되도록 하여, 미리 계산된 해시값 목록(레인보우 테이블)을 이용한 공격을 무력화합니다.
3.  **키 스트레칭 (Key Stretching)** : 해시 함수를 수천~수만 번 반복 적용하여, 해시값을 계산하는 데 걸리는 시간을 의도적으로 늘리는 기법입니다. 이를 통해 무차별 대입 공격(Brute-force attack)의 효율을 급격히 떨어뜨립니다.

> **결론**: 안전한 비밀번호 저장을 위해서는 **"솔트를 사용한 키 스트레칭 해시"**  (예: bcrypt, scrypt, Argon2 라이브러리 사용)가 필수적입니다. bcrypt와 같은 단방향 해시 함수는 숙련된 해커도 긴 평문을 복구하게 어렵게 합니다!

---

## 상태 유지 기술: 쿠키, 세션, 토큰

HTTP는 **무상태(Stateless)**  프로토콜이라 이전 요청을 기억하지 못합니다. 따라서 사용자의 로그인 상태 등을 유지하기 위한 별도의 기술이 필요합니다.

### 쿠키 (Cookie): 브라우저에 저장하는 작은 데이터
- **원리**: 서버가 사용자의 브라우저에 저장하는 작은 텍스트 조각. 브라우저는 이후 모든 요청에 해당 쿠키를 자동으로 포함하여 서버에 전송합니다.
- **용도**: 로그인 상태 유지, 사용자 설정 기억, 장바구니 등.
- **한계**: 클라이언트에 저장되어 보안에 취약하고, 용량 제한(약 4KB)이 있습니다.

### 세션 (Session): 서버에 저장하는 사용자 정보
- **원리**: 서버가 각 사용자의 정보를 서버 메모리나 DB에 직접 저장하고, 브라우저에는 해당 정보를 식별하기 위한 고유한 **세션 ID**만 쿠키에 담아 보냅니다.
- **장점**: 중요한 정보(개인정보 등)를 서버에 저장하므로 쿠키보다 안전합니다.
- **단점**: 사용자가 많아지면 서버의 메모리 부하가 커집니다. 서버를 여러 대로 확장(Scale-out)할 경우, 세션 정보를 모든 서버가 공유해야 하는 복잡한 문제가 발생합니다.

### 토큰 기반 인증 (JWT): 상태 없는 인증 방식
- **원리**: 사용자가 로그인하면, 서버는 사용자의 정보와 권한을 담아 암호학적으로 **서명(Signature)**  된 **토큰(Token)**  을 발급합니다. 클라이언트는 이 토큰을 저장했다가, 요청 시마다 헤더에 포함하여 보냅니다.
- **JWT (JSON Web Token) 구조**: `[헤더].[페이로드].[서명]` 세 부분으로 구성되며, 각 부분은 Base64로 인코딩됩니다.
    - **헤더**: 토큰 유형, 서명 알고리즘 정보.
    - **페이로드**: 사용자 ID, 권한, 만료 시간 등 실제 전달할 정보 (민감 정보는 담지 말아야 함).
    - **서명**: 헤더와 페이로드를 합친 후, 서버만 아는 비밀 키로 서명한 값. 이 서명을 통해 토큰의 위변조 여부를 검증합니다.
- **장점**:
    - **무상태(Stateless) 및 확장성**: 서버가 사용자 상태를 저장할 필요가 없습니다. 어떤 서버로 요청이 가든 토큰의 서명만 검증하면 되므로, **서버 확장에 매우 유리**합니다.
    - **자기완결성**: 토큰 자체에 필요한 모든 정보가 담겨있습니다.

| 구분 | 세션 방식 | 토큰(JWT) 방식 |
|---|---|---|
| **상태 저장 위치** | **서버** | **클라이언트** |
| **서버 상태** | Stateful (상태 유지) | **Stateless (상태 없음)**  |
| **확장성** | 복잡함 (세션 클러스터링 필요) | **용이함** |
| **보안** | 세션 ID 탈취 시 문제 | 토큰 자체 탈취 시 문제 |

> **💡 세션이 더 안전하다고 해서 항상 최선의 선택은 아닙니다**
> 
> 세션이 쿠키보다 보안성이 높은 것은 사실이지만, 현대 웹 개발에서는 다음과 같은 이유로 토큰 기반 인증이 더 선호됩니다:
> 
> **세션의 한계**:
> - **확장성 문제**: 서버가 늘어날 때마다 세션 동기화가 복잡해짐
> - **메모리 부담**: 사용자가 많아질수록 서버 메모리 사용량 급증
> - **모바일 앱 지원**: 쿠키를 사용하지 않는 모바일 앱에서는 세션 관리가 어려움
> 
> **현재 트렌드**:
> - **MSA (마이크로서비스)**: 서비스 간 상태 공유가 어려운 세션보다는 **JWT 토큰**이 유리
> - **SPA (Single Page Application)**: React, Vue 등에서는 토큰 기반 인증이 표준
> - **API 중심 개발**: RESTful API에서는 무상태(Stateless) 토큰이 더 적합
> 
> 따라서 **보안성만으로 기술을 선택하는 것이 아니라, 서비스의 특성과 확장 계획을 종합적으로 고려**해야 합니다.
---

## 성능 최적화와 캐시

**캐시(Cache)**  는 한 번 계산된 결과나 자주 접근하는 데이터의 복사본을 더 빠른 저장소에 임시로 보관하여, 다음 요청 시 빠르게 제공하는 기술입니다.

- **브라우저 캐시**: 웹페이지의 이미지, CSS, JS 파일 등을 사용자 컴퓨터에 저장하여, 재방문 시 사이트 로딩 속도를 향상시킵니다.
- **CDN (Content Delivery Network)** : 전 세계 곳곳에 위치한 캐시 서버에 콘텐츠(영상, 이미지 등)를 미리 복사해두고, 사용자와 가장 가까운 서버에서 콘텐츠를 전송하여 글로벌 서비스의 속도를 획기적으로 개선합니다.
- **LLM 토큰 캐싱**: LLM(대형 언어 모델) API 호출 시, 동일한 입력에 대해 동일한 응답을 반환하는 경우가 많습니다. 이때, 이전에 받은 응답을 캐싱하여 불필요한 API 호출을 줄이고 비용을 절감할 수 있습니다. 대부분의 LLM 서비스는 캐시된 토큰에 대해 비용을 할인해주는 경우가 많습니다.