# 3. 파일 시스템 📁

## 목차
- [3. 파일 시스템 📁](#3-파일-시스템-)
  - [목차](#목차)
  - [파일 시스템이란?: 이름과 실체의 연결고리](#파일-시스템이란-이름과-실체의-연결고리)
    - [파일, 디렉토리, 그리고 메타데이터](#파일-디렉토리-그리고-메타데이터)
  - [파일 할당: 논리적 파일을 물리적 디스크에 저장하는 법](#파일-할당-논리적-파일을-물리적-디스크에-저장하는-법)
    - [연속 할당](#연속-할당)
    - [연결 할당](#연결-할당)
    - [색인 할당 (feat. i-node)](#색인-할당-feat-i-node)
  - [링크: 하나의 파일, 여러 개의 이름](#링크-하나의-파일-여러-개의-이름)
    - [하드 링크 (Hard Link)](#하드-링크-hard-link)
    - [심볼릭 링크 (Symbolic Link)](#심볼릭-링크-symbolic-link)
  - [마운트: 저장 장치를 시스템에 연결하기](#마운트-저장-장치를-시스템에-연결하기)

---

## 파일 시스템이란?: 이름과 실체의 연결고리

**파일 시스템(File System)**  은 운영체제가 하드디스크나 SSD 같은 보조기억장치에 있는 데이터를 **파일(File)**  이라는 논리적 단위로 관리하고, 사용자가 이를 쉽게 사용할 수 있도록 돕는 **체계 또는 메커니즘**입니다.

파일 시스템의 핵심 역할은 두 가지입니다.
1.  **추상화 (Abstraction)** : 사용자가 디스크의 복잡한 물리적 구조(섹터, 블록 등)를 몰라도, `my_document.txt`와 같은 **이름**만으로 데이터에 접근할 수 있게 해줍니다.
2.  **매핑 (Mapping)** : 파일이라는 **논리적 주소**를 디스크 상의 **물리적 주소**로 변환하고, 일관된 API(`open`, `read`, `write`, `close` 등)를 제공하여 데이터 접근을 제어합니다.

### 파일, 디렉토리, 그리고 메타데이터

- **파일 (File)** : 정보를 담는 논리적인 저장 단위입니다.
- **디렉토리 (Directory / Folder)** : 파일들을 계층적으로 관리하기 위한 특수한 파일로, 내부에 포함된 파일들의 **이름과 위치 정보**를 담고 있습니다.
- **메타데이터 (Metadata)** : 파일 자체의 데이터가 아닌, 파일을 설명하는 데이터입니다. 파일 이름, 크기, 유형, 소유자, 권한, 생성/수정 시간 등이 포함됩니다.

> **UNIX/Linux의 철학: "Everything is a File"**
> 리눅스에서는 하드웨어 장치, 네트워크 연결 등 시스템의 모든 것을 파일처럼 다룹니다. 이 철학 덕분에 모든 시스템 자원을 동일한 API(`open`, `read` 등)로 일관되게 제어할 수 있습니다.

---

## 파일 할당: 논리적 파일을 물리적 디스크에 저장하는 법

파일 시스템은 파일을 디스크의 **블록(Block)**  이라는 단위로 나누어 저장합니다. 이때 어떤 방식으로 블록을 할당하는지에 따라 여러 기법으로 나뉩니다.

### 연속 할당
- **방식**: 파일 하나를 디스크의 연속된 블록에 순서대로 저장합니다.
- **장점**: 디스크 헤드의 이동이 적어 읽기 속도가 매우 빠릅니다.
- **단점**: 파일 중간에 데이터를 추가하거나, 파일 크기를 키우기 어렵습니다. 할당과 삭제가 반복되면 **외부 단편화**가 발생합니다.

### 연결 할당
- **방식**: 각 데이터 블록이 다음 블록의 위치를 가리키는 포인터(링크)를 갖는 연결 리스트(Linked List) 형태로 파일을 저장합니다.
- **장점**: 외부 단편화가 발생하지 않고, 파일 크기를 유연하게 늘릴 수 있습니다.
- **단점**: 특정 위치에 직접 접근(Random Access)이 불가능하고, 반드시 첫 블록부터 순차적으로 따라가야 합니다. 중간 링크 하나가 손상되면 파일 전체가 유실될 수 있습니다.
- **FAT (File Allocation Table)** : 연결 할당의 변형으로, 포인터들을 별도의 테이블(FAT)에 모아 관리하여 단점을 일부 보완한 방식입니다. (MS-DOS, Windows 초기 파일 시스템)

### 색인 할당 (feat. i-node)
- **방식**: 파일마다 **인덱스 블록(Index Block)**  이라는 특별한 블록을 두고, 여기에 파일의 데이터가 실제 저장된 모든 블록의 주소를 기록합니다.
- **장점**: 외부 단편화가 없으며, 인덱스 블록만 참조하면 되므로 직접 접근(Random Access)이 매우 빠릅니다.
- **i-node (Index Node)** : UNIX/Linux 계열 파일 시스템(ext4 등)에서 사용하는 색인 할당의 핵심 자료구조입니다. **i-node**는 파일의 **모든 메타데이터(권한, 소유자, 크기 등)와 데이터 블록의 주소 목록**을 담고 있습니다. 디렉토리는 단지 '파일명'과 'i-node 번호'를 연결하는 매핑 테이블 역할만 합니다.

> **i-node는 파일의 '주민등록증'**과 같습니다. 파일명은 바뀔 수 있는 이름일 뿐, 운영체제는 고유한 i-node 번호로 파일을 식별하고 관리합니다.

---

## 링크: 하나의 파일, 여러 개의 이름

링크는 기존 파일에 또 다른 이름을 부여하여, 다른 경로에서도 해당 파일에 접근할 수 있게 하는 기능입니다.

### 하드 링크 (Hard Link)
- **원리**: 하나의 파일 내용(i-node)에 여러 개의 파일 이름을 연결합니다. 즉, **동일한 i-node 번호**를 공유합니다.
- **특징**:
    - 원본 파일을 삭제해도, 링크 카운트가 0이 되기 전까지는 파일 내용이 사라지지 않습니다.
    - 원본과 링크는 사실상 구분이 없는 동일한 파일입니다.
    - **디렉토리에는 생성할 수 없으며, 다른 파일 시스템(파티션)의 파일을 연결할 수 없습니다.**
- **생성**: `ln [원본 파일] [하드 링크 이름]`

### 심볼릭 링크 (Symbolic Link)
- **원리**: 원본 파일을 가리키는 **경로가 저장된** 특수한 파일을 새로 만듭니다. (Windows의 '바로가기'와 유사하지만, OS 수준에서 작동)
- **특징**:
    - 원본 파일이 삭제되거나 경로가 바뀌면 링크가 깨져 '죽은 링크'가 됩니다.
    - 원본과 다른 별개의 파일(다른 i-node 번호)입니다.
    - **디렉토리에도 생성할 수 있으며, 다른 파일 시스템의 파일도 연결할 수 있습니다.**
- **생성**: `ln -s [원본 파일] [심볼릭 링크 이름]`

---

## 마운트: 저장 장치를 시스템에 연결하기

**마운트(Mount)**  란 하드디스크, USB 드라이브, 네트워크 드라이브 등 별도의 저장 장치(와 그 안의 파일 시스템)를, 기존 디렉토리 구조의 특정 위치(**마운트 포인트**)에 연결하여 접근할 수 있도록 만드는 과정입니다.

- **왜 필요한가?**: 운영체제가 새로운 저장 장치를 인식하고, 그 안의 파일 시스템을 읽어 사용자가 파일에 접근할 수 있도록 '사용 준비'를 하는 과정입니다.
- **Windows vs. Linux**: Windows는 USB 등을 연결하면 `D:`, `E:` 와 같이 새로운 드라이브 문자를 할당하며 자동으로 마운트합니다. 반면, Linux에서는 사용자가 직접 `mount` 명령어를 사용하여 특정 디렉토리(예: `/mnt/usb`)에 장치를 연결해야 하는 경우가 많습니다.
- **명령어**: `mount [장치명] [마운트 포인트 디렉토리]`
