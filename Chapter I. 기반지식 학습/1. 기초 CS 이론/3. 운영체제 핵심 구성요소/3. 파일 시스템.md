# 3. 파일 시스템 📁

## 목차
- [3. 파일 시스템 📁](#3-파일-시스템-)
  - [목차](#목차)
  - [파일 시스템: 파일을 관리하는 법칙](#파일-시스템-파일을-관리하는-법칙)
    - [파일이란?](#파일이란)
    - [파일의 메타데이터란?](#파일의-메타데이터란)
    - [디렉토리란?](#디렉토리란)
    - [그래서, 파일 시스템이란?](#그래서-파일-시스템이란)
  - [저장 장치의 접근 방식](#저장-장치의-접근-방식)
    - [하드 디스크?](#하드-디스크)
    - [SSD(Solid State Drive)?](#ssdsolid-state-drive)
  - [다양한 파일 할당 방식](#다양한-파일-할당-방식)
  - [링크: 파일을 연결하는 방식](#링크-파일을-연결하는-방식)
    - [링크의 활용 방법](#링크의-활용-방법)
  - [마운트: 물리 장치를 사용하기 위한 준비](#마운트-물리-장치를-사용하기-위한-준비)
    - [마운트, 왜 필요할까?](#마운트-왜-필요할까)
    - [리눅스에서 마운트 하는 방법?](#리눅스에서-마운트-하는-방법)

---

## 파일 시스템: 파일을 관리하는 법칙


### 파일이란?

파일이란 컴퓨터에서 **정보를 담는 논리적인 저장 단위**이며, 일반적으로 비휘발성 저장장치(주로 보조기억장치)에 저장한다.

### 파일의 메타데이터란?

파일은 관리를 위해 **파일 이름, 파일 유형, 파일 크기, 파일 생성 시간, 파일 수정 시간, 파일 소유자, 파일 권한 등**의 정보를 가지고 있다. 이러한 정보를 **파일의 메타데이터**라고 한다.

### 디렉토리란?

디렉토리는 파일에 대해 여러 정보를 가지고 있는 특수한 파일로서, **파일의 이름과 파일의 메타데이터**를 가지고 있다. 검색, 생성, 삭제 등의 기능을 제공한다.

> 윈도우에서는 폴더라고 불리는 것이 리눅스에서는 디렉토리라고 불리는데, 리눅스는 특히 **모든 것이 파일**이라는 철학을 가지고 있기 때문에 디렉토리도 파일로 취급한다.

### 그래서, 파일 시스템이란?

파일 시스템은 파일을 관리하는 법칙이다. 파일 시스템은 크게 디스크, 네트워크, 그리고 특수 용도의 파일 시스템으로 나뉘며 운영체제는 여러 가지 파일 시스템 중 하나를 채택해 관리한다.

---

## 저장 장치의 접근 방식

할당 방식에 대해 이야기하기 전에 저장장치에 흔히 두가지 방식이 있음을 언급하고자 한다. 순차 접근 저장장치는 카세트 테이프와 같이 감는 순서대로 읽고 쓰는 방식이며, 직접 접근 저장장치는 하드디스크와 같이 임의의 위치로 직접 접근하여 읽고 쓰는 방식이다.

### 하드 디스크?

하드디스크는 지금은 SSD보다 덜 사용하지만 여전히 많이 사용되는 저장장치이다. 하드디스크는 **플래터**라는 원판 위에 자성체를 이용해 데이터를 저장하며, **헤드**라는 기계로 플래터를 읽고 쓴다. 플래터는 **트랙**이라는 원형의 구역으로 나뉘며, 트랙은 **섹터**라는 작은 단위로 나뉜다.

### SSD(Solid State Drive)?

SSD는 하드디스크와 달리 기계적 부품이 없는 저장장치로, **플래시 메모리**를 이용해 데이터를 저장한다. 하드디스크보다 속도가 빠르고 내구성이 높으며, 소음이 없고 발열이 적다.

---

## 다양한 파일 할당 방식

하드 디스크는 블록이라는 단위로 나누어 번호를 붙여 저장하며, 파일을 저장할 때는 다음과 같은 다양한 할당 방식이 있다.

1. 연속 할당(Contiguous Allocation)

- 파일을 연속적인 블록에 저장하는 방식
- 헤드의 이동을 최소화하여 입출력 속도가 빠름
- 순차 접근과 직접 접근이 모두 가능
- 할당과 삭제 반복 시 외부 단편화 발생 가능
- 파일이 계속 커지는 경우 부적절한 방법
  
2. 연결 할당(Linked Allocation)

- 파일을 연결 리스트로 연결하여 저장하는 방식
- 데이터와 주소를 저장하는 공간으로 나눠서 사용
- 헤드가 여러 번 움직여야 하고, 직접 접근이 불가능
- 링크드 리스트 특성상 노드 하나라도 손상되면 파일 전체가 손상될 수 있음
- 외부 단편화가 발생하지 않음

> **연결 리스트**란?: 각 노드가 데이터와 다음 노드를 가리키는 주소를 가지고 있는 자료구조

3. FAT(File Allocation Table)
- 연결 할당 방식에서 발생하는 문제점을 해결하기 위해 도입된 방식
- 파일의 포인터를 **하나의 중앙 테이블에 저장**하여 파일을 찾을 수 있도록 함
- FAT만 읽어두면 직접 접근도 가능하고, 손상되어도 FAT를 보는 방식으로 다음 칸 추정 가능
- 최대 파일 크기와 파티션 크기가 제한되는 단점이 있음
- 칸의 번호를 몇 비트로 버전할것인지에 따라 버전이 달라짐(FAT16, FAT32, exFAT)

4. 색인 할당(Indexed Allocation)
   
- 파일의 포인터를 **인덱스(색인) 블록**에 저장하여 파일을 찾을 수 있도록 함
- **각 파일마다** 자체적인 인덱스 블록을 가지고 있음
- 직접 접근이 가능하고, 파일이 커져도 인덱스 블록만 늘리면 되기 때문에 파일 크기에 제한이 없음
- 표를 저장하기 위해 파일마다 한 칸을 사용해야 하고, 한 칸에 들어갈 수 없을 정도로 큰 파일은 저장 불가능

5. i-node 방식

- UNIX 계열 운영체제에서 사용하는 방식
- 파일의 메타데이터와 데이터 블록 주소를 i-node에 저장하여 파일을 찾을 수 있도록 함

> i-node라는 이름을 사용하긴 하지만 자료구조 node랑 직접적인 관련성은 없다. 오히려 선형 배열 구조에 가깝다!

---

## 링크: 파일을 연결하는 방식

링크는 파일을 연결하는 방식이다. **하드 링크**와 **심볼릭 링크**로 나뉜다.

1. 심볼릭 링크(Symbolic Link)
- 파일을 가리키는 **심볼릭 링크 파일**을 생성하는 방식
- 심볼릭 링크 파일의 inode에는 **원본 파일의 경로**가 저장되어 있음
- 원본 파일이 경로가 변경되거나 삭제되면 심볼릭 링크 파일은 끊어지게 됨
- 생성 방법은 다음과 같음:
  ```bash
  ln -s [원본 파일] [심볼릭 링크 파일]
  ```
2. 하드 링크(Hard Link)
- 링크가 원본 파일의 inode를 공유함
- 따라서, 원본 파일을 이동 혹은 삭제해도 하드 링크 파일을 그대로 사용 가능
- 링크 파일의 수정이 원본 파일의 수정으로 이어짐
- 생성 방법은 다음과 같음:
  ```bash
  ln [원본 파일] [하드 링크 파일]
  ```

> 윈도우의 바로가기는 하드 링크나 심볼릭 링크와는 다르게 셸 링크(Shell Link)라는 별도의 개념이다. [마이크로소프트 공식 문서](https://learn.microsoft.com/ko-kr/windows/win32/shell/links)에서 읽어보자.

### 링크의 활용 방법

링크를 만듦으로서 **대량의 데이터를 직접 복사하지 않을 수 있고, 여러 위치에 같은 데이터가 저장된것처럼 사용 가능하지만 기억장치 용량은 하나만 사용**한다. 단, 심볼릭 링크와 하드 링크의 차이에 따라 링크 파일의 수정에도 신중해야 한다.

---

## 마운트: 물리 장치를 사용하기 위한 준비

새로운 물리 장치를 사용하기 위해서는 반드시 마운트를 해야 한다. 일부 운영체제에서는 자동으로 마운트를 실행한다. 대부분의 저장장치는 마운트를 요한다.

### 마운트, 왜 필요할까?

마운트는 **물리 장치를 사용하기 위한 준비**이다. 물리 장치를 사용하기 위해서는 운영체제가 해당 장치를 인식하고, 해당 장치를 사용할 수 있도록 준비해야 한다. 주로 사용하는 윈도우와 같은 운영체제는 마운트를 자동으로 해 주기 때문에, 마운트의 필요성을 간과하기 쉽다.

### 리눅스에서 마운트 하는 방법?

```bash
mount [옵션][장치명] [마운트 지점]
```
여기서 장치명은 장치의 이름을 쓰고, 마운트 지점은 장치를 연결할 디렉토리를 쓴다.