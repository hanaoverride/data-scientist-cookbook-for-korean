# 4. 리눅스 프로세스와 네트워크 관리 🖥️

## 목차
- [4. 리눅스 프로세스와 네트워크 관리 🖥️](#4-리눅스-프로세스와-네트워크-관리-️)
  - [목차](#목차)
  - [프로세스 관리: 내 컴퓨터에선 무슨 일이?](#프로세스-관리-내-컴퓨터에선-무슨-일이)
    - [프로세스 목록 확인: `ps`](#프로세스-목록-확인-ps)
    - [프로세스에 신호 보내기: `kill`](#프로세스에-신호-보내기-kill)
  - [작업 제어: 포어그라운드와 백그라운드](#작업-제어-포어그라운드와-백그라운드)
  - [작업 예약: 미래의 나에게 일 시키기](#작업-예약-미래의-나에게-일-시키기)
    - [한 번만 실행: `at`](#한-번만-실행-at)
    - [주기적으로 실행: `cron`](#주기적으로-실행-cron)
  - [원격 접속의 표준: SSH](#원격-접속의-표준-ssh)

---

## 프로세스 관리: 내 컴퓨터에선 무슨 일이?

리눅스에서 실행 중인 모든 프로그램은 **프로세스** 단위로 관리됩니다. 각 프로세스는 고유한 번호인 **PID(Process ID)**  를 가지며, 운영체제는 이 PID를 통해 특정 프로세스를 식별하고 제어합니다.

### 프로세스 목록 확인: `ps`

`ps` (Process Status) 명령어는 현재 실행 중인 프로세스의 목록과 상태를 보여줍니다.

| 주요 옵션 조합 | 설명 |
|---|---|
| `ps aux` | **시스템의 모든 프로세스**를 **사용자 중심**의 상세 정보와 함께 보여줍니다. (가장 널리 쓰임) |
| `ps -ef` | **시스템의 모든 프로세스**를 **프로세스 간의 관계(부모-자식)** 를 포함한 상세 정보로 보여줍니다. |

```bash
# 현재 실행 중인 파이썬 스크립트의 PID 찾기
$ ps aux | grep "python"
alice     12345  0.5  1.2 123456 24680 pts/0    S+   10:30   0:01 python my_script.py
```
> 위 예시에서 `ps aux`의 결과를 파이프로 `grep`에 넘겨, 'python'이라는 단어가 포함된 줄만 필터링했습니다. 프로세스 ID(PID)는 `12345`임을 알 수 있습니다.

### 프로세스에 신호 보내기: `kill`

`kill` 명령어는 이름과 달리 단순히 프로세스를 죽이는 것이 아니라, 특정 프로세스에 **시그널(Signal)**  이라는 메시지를 보내는 역할을 합니다. 어떤 시그널을 보내느냐에 따라 프로세스의 행동이 달라집니다.

`kill -[시그널 번호] [PID]`

| 시그널 번호 | 시그널 이름 | 설명 |
|---|---|---|
| **15** (기본값) | **SIGTERM** | "이제 작업을 정리하고 **안전하게 종료**해주세요." 라고 정중하게 요청하는 신호입니다. |
| **9** | **SIGKILL** | "묻지도 따지지도 말고 **즉시 강제 종료**해라." 라고 명령하는 신호입니다. 데이터 유실의 위험이 있습니다. |
| **1** | **SIGHUP** | "설정 파일을 다시 읽고 **재시작**해주세요." 라고 요청하는 신호입니다. (주로 데몬 프로세스에 사용) |

> **올바른 종료 순서**: 먼저 `kill [PID]` (SIGTERM)를 보내 정상 종료를 시도하고, 프로그램이 응답하지 않을 때 최후의 수단으로 `kill -9 [PID]` (SIGKILL)를 사용해야 합니다.

---

## 작업 제어: 포어그라운드와 백그라운드

리눅스 셸에서는 작업을 두 가지 방식으로 실행할 수 있습니다.

- **포어그라운드 (Foreground)** : 명령어를 입력하면 해당 작업이 끝날 때까지 셸을 사용할 수 없는 기본 실행 방식입니다.
- **백그라운드 (Background)** : 명령어 뒤에 `&`를 붙이면, 작업이 뒤에서 실행되는 동안 셸에서는 다른 작업을 계속할 수 있습니다.

| 명령어 | 설명 |
|---|---|
| `[명령어] &` | 명령어를 백그라운드에서 실행합니다. |
| `jobs` | 현재 셸에서 실행 중인 백그라운드 작업 목록을 보여줍니다. |
| `fg %[작업번호]` | 백그라운드 작업을 포어그라운드로 전환합니다. |
| `bg %[작업번호]` | 멈춰있는 작업을 백그라운드에서 다시 실행합니다. |
| `Ctrl + Z` | 현재 포어그라운드에서 실행 중인 작업을 **일시 정지**시키고 백그라운드로 보냅니다. |

---

## 작업 예약: 미래의 나에게 일 시키기

### 한 번만 실행: `at`
`at` 명령어는 지정된 시간에 **단 한 번만** 실행될 작업을 예약합니다.

```bash
# 내일 새벽 3시에 update_db.sh 스크립트 실행 예약
$ at 3am tomorrow < /home/alice/scripts/update_db.sh

# 예약된 작업 목록 확인
$ atq

# 2번 작업 삭제
$ atrm 2
```

### 주기적으로 실행: `cron`
`cron`은 특정 시간에 **주기적으로 반복**되는 작업을 예약하는 강력한 시스템 데몬입니다. `crontab -e` 명령어로 예약 작업을 편집합니다.

**`crontab` 형식**:
`분(0-59) 시(0-23) 일(1-31) 월(1-12) 요일(0-6) /실행할/명령어/경로`
(`*`는 '매번'을 의미)

```bash
# crontab 편집기 열기
$ crontab -e

# 편집기에 아래 내용 추가

# 매일 새벽 2시 30분에 데이터 백업 스크립트 실행
30 2 * * * /home/alice/scripts/backup.sh

# 매주 월요일 오전 9시에 주간 보고서 생성 스크립트 실행
0 9 * * 1 /home/alice/scripts/weekly_report.py > /home/alice/reports/latest.log 2>&1
```
> **데이터 사이언티스트와 `cron`**: `cron`은 데이터 과학자의 개인 비서입니다. 매일 특정 시간에 데이터를 수집하거나, 모델을 재학습시키거나, 보고서를 생성하는 모든 반복 작업을 자동화하는 데 필수적입니다.

---

## 원격 접속의 표준: SSH

**SSH (Secure SHell)**  는 암호화된 통신 채널을 통해 다른 컴퓨터에 원격으로 안전하게 접속하고, 명령을 실행하고, 파일을 전송할 수 있게 해주는 프로토콜입니다. 데이터 사이언티스트가 클라우드 서버나 사내 GPU 서버에 접속할 때 반드시 사용합니다.

`ssh [사용자명]@[서버 주소(IP 또는 도메인)]`

```bash
# 192.168.1.10 서버에 alice라는 사용자로 접속
$ ssh alice@192.168.1.10
```

> **SSH 키 기반 인증**: 실무 환경에서는 보안을 위해 비밀번호 대신 **SSH 키(Key)**  를 사용한 인증이 표준입니다. `ssh-keygen`으로 암호화된 키 쌍(개인키/공개키)을 생성하고, 내 공개키를 접속하려는 서버에 미리 등록해두면 비밀번호 없이 안전하고 편리하게 접속할 수 있습니다. 또한 CloudFlare의 Zero Trust를 사용하면 유일하게 허용된 웹 SSH 클라이언트만 접속할 수 있도록 제한할 수 있습니다.

