# 3. 비선형 자료구조의 대표, 트리 🌳

## 목차
- [3. 비선형 자료구조의 대표, 트리 🌳](#3-비선형-자료구조의-대표-트리-)
  - [목차](#목차)
  - [트리(Tree): 계층적 관계를 표현하다](#트리tree-계층적-관계를-표현하다)
  - [트리 순회: 모든 노드를 방문하는 방법](#트리-순회-모든-노드를-방문하는-방법)
    - [깊이 우선 탐색 (DFS): 끝까지 파고들기](#깊이-우선-탐색-dfs-끝까지-파고들기)
    - [너비 우선 탐색 (BFS): 주변부터 훑어보기](#너비-우선-탐색-bfs-주변부터-훑어보기)
  - [이진 탐색 트리 (BST): 효율적인 탐색을 위한 트리](#이진-탐색-트리-bst-효율적인-탐색을-위한-트리)
    - [이진 탐색 트리의 한계와 균형 트리](#이진-탐색-트리의-한계와-균형-트리)
  - [트리의 활용 사례](#트리의-활용-사례)

---

## 트리(Tree): 계층적 관계를 표현하다

지금까지 다룬 배열, 스택, 큐가 데이터를 일렬로 나열하는 **선형 구조**였다면, **트리**는 부모-자식 관계를 가지는 노드들로 이루어진 **계층적 비선형 자료구조**입니다. 회사의 조직도나 컴퓨터의 파일 시스템처럼, 계층적인 데이터를 표현하는 데 매우 효과적입니다.

- **주요 용어**:
    - **노드(Node)** : 트리를 구성하는 각각의 요소.
    - **루트(Root)** : 트리의 가장 최상위에 있는 노드.
    - **부모/자식(Parent/Child)** : 특정 노드를 기준으로, 바로 위 계층의 노드는 부모, 바로 아래 계층의 노드는 자식.
    - **리프(Leaf)** : 자식이 없는, 가장 마지막에 있는 노드.
- **이진 트리(Binary Tree)** : 모든 노드의 자식이 2개 이하인 트리. 데이터 구조에서 가장 널리 사용되는 형태입니다.

```mermaid
graph TD
    A[A (루트)] --> B[B]
    A --> C[C]
    B --> D[D (리프)]
    B --> E[E (리프)]
    C --> F[F (리프)]
    
    classDef root fill:#d5f5e3
    classDef leaf fill:#ebdef0
    class A root
    class D,E,F leaf
```

---

## 트리 순회: 모든 노드를 방문하는 방법

트리의 모든 노드를 한 번씩 방문하는 것을 **순회(Traversal)** 라고 하며, 크게 두 가지 방식으로 나뉩니다.

### 깊이 우선 탐색 (DFS): 끝까지 파고들기

**DFS(Depth-First Search)** 는 자식 노드를 따라 가능한 한 깊이 들어간 후, 더 이상 갈 곳이 없으면 되돌아와 다른 경로를 탐색하는 방식입니다. **재귀(Recursion)**  또는 **스택(Stack)** 을 사용하여 구현합니다.

이진 트리에서 '현재 노드'를 언제 방문(처리)하느냐에 따라 세 가지 방식으로 나뉩니다.

1.  **전위 순회 (Pre-order)** : **나(루트)**  -> 왼쪽 자식 -> 오른쪽 자식
2.  **중위 순회 (In-order)** : 왼쪽 자식 -> **나(루트)**  -> 오른쪽 자식
3.  **후위 순회 (Post-order)** : 왼쪽 자식 -> 오른쪽 자식 -> **나(루트)** 

```python
# 재귀를 이용한 중위 순회 구현
def inorder_traversal(node):
    if node is None:
        return
    inorder_traversal(node.left)
    print(node.value, end=' ') # 방문 (처리)
    inorder_traversal(node.right)
```

### 너비 우선 탐색 (BFS): 주변부터 훑어보기

**BFS(Breadth-First Search)** 는 루트 노드에서 시작하여, 가까운 노드부터 차례대로, 즉 **레벨(level) 순서**로 탐색하는 방식입니다. **큐(Queue)** 를 사용하여 구현합니다.

```python
from collections import deque

def bfs_traversal(root):
    if root is None:
        return
    
    queue = deque([root]) # 큐에 루트 노드를 넣고 시작
    while queue:
        node = queue.popleft() # 큐의 맨 앞에서 노드를 꺼내 방문
        print(node.value, end=' ') # 방문 (처리)
        
        # 방문한 노드의 자식들을 큐의 맨 뒤에 추가
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
```

---

## 이진 탐색 트리 (BST): 효율적인 탐색을 위한 트리

**이진 탐색 트리(Binary Search Tree, BST)** 는 효율적인 탐색을 위해 다음과 같은 규칙을 가지는 이진 트리입니다.

- **규칙**:
    1.  모든 노드의 **왼쪽 서브트리**에는 현재 노드의 값보다 **작은** 값들만 존재합니다.
    2.  모든 노드의 **오른쪽 서브트리**에는 현재 노드의 값보다 **큰** 값들만 존재합니다.
    3.  모든 서브트리 또한 이진 탐색 트리입니다.

- **특징**:
    - 이 규칙 덕분에, 특정 값을 찾을 때 매번 탐색 범위가 절반으로 줄어들어 평균적으로 **O(log n)** 의 매우 빠른 탐색 속도를 보입니다.
    - 이진 탐색 트리를 **중위 순회(in-order)** 하면, 노드의 값들이 **오름차순으로 정렬**된 결과를 얻을 수 있습니다.

### 이진 탐색 트리의 한계와 균형 트리

- **한계**: 데이터가 `1, 2, 3, 4, 5` 처럼 순서대로 삽입되면, 트리가 한쪽으로만 길게 늘어선 **편향 트리(Skewed Tree)** 가 됩니다. 이 경우, 탐색 성능이 연결 리스트와 같은 **O(n)** 으로 저하됩니다.
- **해결책**: **균형 이진 탐색 트리 (Self-Balancing BST)** 는 삽입/삭제 시 스스로 노드의 위치를 재조정하여 트리가 항상 균형을 유지하도록 만듭니다. 이를 통해 최악의 경우에도 **O(log n)** 의 성능을 보장합니다. 대표적으로 **AVL 트리**, **레드-블랙 트리(Red-Black Tree)** 가 있습니다.

---

## 트리의 활용 사례

- **파일 시스템**: 디렉토리와 파일의 계층 구조를 표현합니다.
- **데이터베이스 인덱스**: B-트리, B+트리 같은 트리 구조를 사용하여 데이터를 빠르게 검색할 수 있도록 돕습니다.
- **HTML/XML 문서 구조 (DOM)** : 웹 브라우저는 HTML 문서를 파싱하여 DOM(Document Object Model) 트리로 변환한 뒤 화면에 렌더링합니다.
- **조직도 및 의사결정 트리**: 계층적인 관계나 분류 기준을 표현하는 데 사용됩니다.