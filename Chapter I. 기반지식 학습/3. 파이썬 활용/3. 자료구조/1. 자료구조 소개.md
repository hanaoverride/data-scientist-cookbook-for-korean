# 1. 자료구조: 데이터의 효율적인 관리 기술 💾

## 목차
- [1. 자료구조: 데이터의 효율적인 관리 기술 💾](#1-자료구조-데이터의-효율적인-관리-기술-)
  - [목차](#목차)
  - [자료구조란 무엇인가?](#자료구조란-무엇인가)
    - [추상적 자료형 (ADT): 기능 명세서](#추상적-자료형-adt-기능-명세서)
  - [기본 자료구조: 배열 vs. 연결 리스트](#기본-자료구조-배열-vs-연결-리스트)
    - [배열 (Array): 순서대로 나열된 상자들](#배열-array-순서대로-나열된-상자들)
    - [연결 리스트 (Linked List): 기차처럼 연결된 칸들](#연결-리스트-linked-list-기차처럼-연결된-칸들)
    - [배열 vs. 연결 리스트: 언제 무엇을 쓸까?](#배열-vs-연결-리스트-언제-무엇을-쓸까)
  - [핵심 자료구조: 해시 테이블 (파이썬의 딕셔너리)](#핵심-자료구조-해시-테이블-파이썬의-딕셔너리)
    - [해시 함수와 충돌](#해시-함수와-충돌)
  - [문제 해결을 통한 자료구조 선택](#문제-해결을-통한-자료구조-선택)
    - [사례 1: 양쪽 끝에서 공 삽입하기](#사례-1-양쪽-끝에서-공-삽입하기)
    - [사례 2: 주문 처리 시스템 최적화](#사례-2-주문-처리-시스템-최적화)
  - [알고리즘 성능의 척도: 시간 복잡도 (Big-O)](#알고리즘-성능의-척도-시간-복잡도-big-o)

---

## 자료구조란 무엇인가?

**자료구조(Data Structure)** 란 여러 데이터들을 특정 구조에 따라 효율적으로 저장하고, 그 데이터에 대한 접근과 수정을 용이하게 하기 위한 **데이터의 조직, 관리, 저장 형식**입니다. 어떤 자료구조를 선택하느냐에 따라 프로그램의 성능이 크게 달라지기 때문에, 문제의 특성에 맞는 최적의 자료구조를 선택하는 것이 매우 중요합니다.

### 추상적 자료형 (ADT): 기능 명세서

**추상적 자료형(Abstract Data Type, ADT)** 은 자료구조의 **'무엇을 할 수 있는가(What)'**를 정의한 기능 명세서입니다. ADT는 데이터가 어떤 속성을 가지며, 어떤 연산(삽입, 삭제, 조회 등)이 가능한지를 정의하지만, **'어떻게(How)'** 구현할지에 대해서는 명시하지 않습니다.
예를 들어, **스택(Stack)** 이라는 자료구조를 생각해봅시다.

- **추상적 자료형 (ADT) 관점**: 스택은 '마지막에 넣은 데이터를 가장 먼저 꺼내는(LIFO, Last-In, First-Out)' 특징을 가지며, 데이터를 넣는 `push()` 연산과 데이터를 꺼내는 `pop()` 연산을 할 수 있다고 정의됩니다. 이것이 ADT입니다.
- **자료구조 관점**: 이 스택 ADT를 실제로 구현하는 방법은 다양합니다. 파이썬의 `list`처럼 **배열**을 사용하여 구현할 수도 있고, **연결 리스트**를 사용하여 구현할 수도 있습니다. 이것이 실제 자료구조입니다.

---

## 기본 자료구조: 배열 vs. 연결 리스트

### 배열 (Array): 순서대로 나열된 상자들

**배열**은 **물리적 메모리 공간에 연속적으로** 데이터를 저장하는 구조입니다. 각 데이터는 고유한 **인덱스(index)** 를 가지며, 이 인덱스를 통해 원하는 데이터에 즉시 접근할 수 있습니다.

- **장점**: 인덱스를 통한 조회(읽기) 속도가 매우 빠릅니다. **O(1)** 
- **단점**: 중간에 데이터를 삽입하거나 삭제할 때, 그 뒤의 모든 데이터를 한 칸씩 이동시켜야 하므로 매우 비효율적입니다. **O(n)** 
- **파이썬 구현**: 파이썬의 기본 `list` 타입은 내부적으로 **동적 배열(Dynamic Array)** 로 구현되어 있습니다.

### 연결 리스트 (Linked List): 기차처럼 연결된 칸들

**연결 리스트**는 각 데이터 조각(**노드, Node**)이 실제 데이터와 **다음 노드를 가리키는 포인터(주소)** 를 함께 가지고 있는 구조입니다. 데이터들이 메모리상에 흩어져 있어도 포인터를 통해 논리적으로 연결됩니다.

- **장점**: 데이터의 삽입과 삭제가 포인터 연결만 바꿔주면 되므로 매우 빠릅니다. **O(1)** 
- **단점**: 특정 위치의 데이터를 찾으려면 첫 노드부터 순서대로 따라가야 하므로 조회 속도가 느립니다. **O(n)** 
- **파이썬 구현**: `collections.deque`가 이중 연결 리스트로 구현되어 있습니다.

### 배열 vs. 연결 리스트: 언제 무엇을 쓸까?

| 구분 | 배열 (Python `list`) | 연결 리스트 (Python `deque`) |
|---|---|---|
| **조회 (읽기)**  | **매우 빠름 (O(1))**  | 느림 (O(n)) |
| **삽입/삭제** | 느림 (특히 맨 앞/중간) (O(n)) | **매우 빠름 (O(1))**  |
| **메모리** | 연속된 공간 필요 | 흩어진 공간 활용 가능 |
| **적합한 경우** | 데이터 조회가 빈번하고, 크기 변동이 적을 때 | 데이터의 추가/삭제가 빈번할 때 |

---

## 핵심 자료구조: 해시 테이블 (파이썬의 딕셔너리)

**해시 테이블(Hash Table)** 은 **키(Key)를 값(Value)에 대응**시키는 자료구조로, 매우 빠른 데이터 검색, 삽입, 삭제를 지원합니다. 파이썬의 **딕셔너리(`dict`)** 와 **집합(`set`)** 이 내부적으로 해시 테이블로 구현되어 있습니다.

### 해시 함수와 충돌

1.  **해시 함수 (Hash Function)** : 임의의 길이의 키(예: "Alice")를 입력받아, 고정된 길이의 숫자(해시값 또는 해시)로 변환합니다. 이 해시값을 배열의 인덱스로 사용하여 값을 저장합니다.
2.  **시간 복잡도**: 이 덕분에 키를 통해 값을 찾거나 저장하는 연산이 평균적으로 **O(1)** 의 매우 빠른 속도를 가집니다.
3.  **충돌 (Collision)** : 서로 다른 키가 우연히 같은 해시값으로 변환되는 현상입니다. 좋은 해시 테이블은 이 충돌을 효과적으로 해결하는 전략(예: 체이닝, 개방 주소법)을 가지고 있어야 합니다.

---

## 문제 해결을 통한 자료구조 선택

### 사례 1: 양쪽 끝에서 공 삽입하기
- **문제**: 양쪽 끝에서 데이터의 추가/삭제가 빈번하게 일어나는 경우.
- **배열(`list`) 사용 시**: `list.insert(0, ...)`는 맨 앞에 삽입할 때마다 모든 원소를 뒤로 밀어야 하므로 **O(n)** 의 비용이 발생하여 비효율적입니다.
- **연결 리스트(`deque`) 사용 시**: `deque.appendleft(...)`는 포인터 조작만으로 맨 앞에 삽입이 가능하므로 **O(1)** 의 비용이 발생하여 매우 효율적입니다.
- **결론**: 이 문제에는 **`collections.deque`**가 최적의 자료구조입니다.

### 사례 2: 주문 처리 시스템 최적화
- **요구사항**: 주문 추가, 특정 ID의 주문 취소, 특정 ID의 주문 순서 조회가 모두 빨라야 함.
- **배열/리스트 사용 시**: 주문 취소(`remove`)나 조회(`index`)를 위해 모든 주문을 순차적으로 탐색해야 하므로 **O(n)** 의 비용이 발생합니다.
- **최적화**: **해시 테이블(딕셔너리) + 이중 연결 리스트**를 함께 사용합니다.
    - **해시 테이블**: `order_id`를 Key로, 주문 노드(객체)를 Value로 저장하여 **O(1)** 만에 특정 주문을 찾습니다.
    - **이중 연결 리스트**: 주문의 순서를 유지하며, 찾은 노드의 앞/뒤 포인터만 수정하여 **O(1)** 만에 주문을 취소(삭제)합니다.

---

## 알고리즘 성능의 척도: 시간 복잡도 (Big-O)

**시간 복잡도**는 입력 데이터의 크기(n)가 증가함에 따라, 알고리즘의 실행 시간이 얼마나 증가하는지를 나타내는 척도입니다. **빅오(Big-O) 표기법**을 사용합니다.

- **O(1) (상수 시간)** : 데이터 크기와 상관없이 항상 일정한 시간이 걸립니다. (예: 해시 테이블 조회)
- **O(log n) (로그 시간)** : 데이터가 2배로 늘어도, 실행 시간은 1단계만 늘어납니다. (예: 이진 탐색)
- **O(n) (선형 시간)** : 데이터 크기와 비례하여 실행 시간이 늘어납니다. (예: 리스트 순회)
- **O(n²) (제곱 시간)** : 데이터가 2배로 늘면, 실행 시간은 4배로 늘어납니다. (예: 이중 for 루프)
