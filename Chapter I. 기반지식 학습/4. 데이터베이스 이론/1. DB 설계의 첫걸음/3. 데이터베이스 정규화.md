# 3. 데이터베이스 정규화: 중복을 제거하고 무결성 높이기

## 목차
- [3. 데이터베이스 정규화: 중복을 제거하고 무결성 높이기](#3-데이터베이스-정규화-중복을-제거하고-무결성-높이기)
  - [목차](#목차)
  - [정규화는 왜 필요한가?: 데이터 이상 현상](#정규화는-왜-필요한가-데이터-이상-현상)
  - [정규화의 기반: 함수 종속성](#정규화의-기반-함수-종속성)
  - [제1정규형 (1NF): 모든 값은 원자적이어야 한다](#제1정규형-1nf-모든-값은-원자적이어야-한다)
  - [제2정규형 (2NF): 부분 함수 종속 제거](#제2정규형-2nf-부분-함수-종속-제거)
  - [제3정규형 (3NF): 이행 함수 종속 제거](#제3정규형-3nf-이행-함수-종속-제거)
  - [정규화 vs. 반정규화: 성능과의 트레이드오프](#정규화-vs-반정규화-성능과의-트레이드오프)

---

## 정규화는 왜 필요한가?: 데이터 이상 현상

데이터베이스 테이블을 잘못 설계하면, 데이터를 삽입, 수정, 삭제할 때 예기치 않은 문제가 발생하는 **이상 현상(Anomaly)** 이 발생할 수 있습니다.

- **갱신 이상 (Update Anomaly)** : 중복된 데이터 중 일부만 수정되어 데이터의 일관성이 깨지는 현상. (예: 고객의 주소를 바꾸기 위해, 해당 고객의 모든 주문 내역을 찾아 주소를 일일이 수정해야 함)
- **삽입 이상 (Insertion Anomaly)** : 불필요한 데이터 없이는 원하는 데이터를 추가할 수 없는 현상. (예: 아직 주문한 적 없는 신규 고객은, 주문 정보가 없다는 이유로 고객 테이블에 등록조차 할 수 없음)
- **삭제 이상 (Deletion Anomaly)** : 특정 정보를 삭제했더니, 원치 않는 다른 정보까지 함께 삭제되는 현상. (예: 고객의 마지막 주문 내역을 삭제했더니, 해당 고객의 정보 자체가 사라져 버림)

**정규화(Normalization)** 는 이러한 이상 현상을 방지하기 위해, 테이블을 특정 규칙에 따라 분리하여 **데이터의 중복을 최소화하고 무결성을 보장**하는 과정입니다.

---

## 정규화의 기반: 함수 종속성

정규화는 테이블 내의 속성(열)들 간의 **함수 종속성(Functional Dependency)**  관계를 분석하는 것에서 시작합니다. "A를 알면 B를 알 수 있다"면, "B는 A에 함수적으로 종속된다"고 말하며 `A -> B`로 표기합니다.

- **예시**: `주문번호 -> 주문일자`, `고객ID -> 고객이름`, `상품코드 -> 상품명`

---

## 제1정규형 (1NF): 모든 값은 원자적이어야 한다

**"테이블의 모든 열은 반드시 원자적인(atomic) 값만 가져야 한다."** 

이는 하나의 열에 여러 개의 값이 리스트나 묶음 형태로 들어가서는 안 된다는 의미입니다.

- **위반 예시**:
  
| 주문번호 | 주문상품 |
|---|---|
| 1001 | '사과', '바나나' |

- **1NF 만족**:
  
| 주문번호 | 상품 |
|---|---|
| 1001 | '사과' |
| 1001 | '바나나' |

---

## 제2정규형 (2NF): 부분 함수 종속 제거

**"테이블의 모든 열은 반드시 기본 키(Primary Key) 전체에 종속되어야 한다."** 

이 규칙은 **복합 키(두 개 이상의 열로 구성된 기본 키)** 를 가진 테이블에 적용됩니다. 기본 키의 일부에만 종속되는 열(부분 함수 종속)이 있다면, 테이블을 분리해야 합니다.

- **위반 예시**: 기본 키가 `{고객ID, 상품ID}`인 주문 테이블
  
| 고객ID | 상품ID | **고객이름** | 주문수량 |
|---|---|---|---|
| alice | P01 | 앨리스 | 5 |
| alice | P02 | 앨리스 | 2 |
> `고객이름`은 기본 키 전체(`{고객ID, 상품ID}`)가 아닌, `고객ID`라는 일부에만 종속됩니다. 이로 인해 '앨리스'라는 이름이 불필요하게 중복 저장됩니다.

- **2NF 만족**: `고객` 테이블과 `주문` 테이블로 분리합니다.
  - **고객 테이블**: `고객ID (PK)`, `고객이름`
  - **주문 테이블**: `고객ID (FK)`, `상품ID (FK)`, `주문수량`

---

## 제3정규형 (3NF): 이행 함수 종속 제거

**"기본 키가 아닌 모든 열은 서로 종속될 수 없다."** 

기본 키에 종속된 일반 열이, 또 다른 일반 열을 결정하는 관계(이행 함수 종속)가 존재해서는 안 됩니다. (`A -> B`이고 `B -> C`일 때, `A -> C`가 성립하는 관계)

- **위반 예시**:
  
| 주문ID (PK) | 고객ID | **고객등급** | **할인율** |
|---|---|---|---|
| 1001 | alice | VIP | 15% |
| 1002 | bob | Gold | 10% |
> `고객ID -> 고객등급` 이고, `고객등급 -> 할인율` 입니다. 즉, `할인율`은 기본 키가 아닌 `고객등급`에 종속됩니다. 만약 VIP 등급의 할인율이 20%로 변경되면, 모든 VIP 고객의 주문 내역을 찾아 할인율을 수정해야 하는 '갱신 이상'이 발생합니다.

- **3NF 만족**: `고객` 테이블과 `주문` 테이블로 분리합니다.
  - **고객 테이블**: `고객ID (PK)`, `고객등급`, `할인율` (또는 `등급` 테이블을 따로 만들어 `등급 -> 할인율` 관계를 저장)
  - **주문 테이블**: `주문ID (PK)`, `고객ID (FK)`

---

## 정규화 vs. 반정규화: 성능과의 트레이드오프

| 구분 | 정규화 (Normalization) | 반정규화 (Denormalization) |
|---|---|---|
| **목표** | **데이터 중복 최소화**, 무결성 확보 | **조회 성능 최적화** |
| **과정** | 규칙에 따라 테이블을 **분리(쪼갬)**  | 성능을 위해 의도적으로 테이블을 **통합**하고 중복을 허용 |
| **장점** | 데이터 일관성 유지, 저장 공간 효율화 | 테이블 조인(JOIN) 횟수를 줄여 조회 속도 향상 |
| **단점** | 데이터를 얻기 위해 여러 테이블을 조인해야 하므로 조회 성능이 저하될 수 있음 | 데이터 중복으로 인한 삽입/수정/삭제 이상 발생 가능, 데이터 관리 비용 증가 |

> **결론**: 실무에서는 먼저 **3NF까지 정규화를 진행**하여 데이터 모델의 일관성을 확보한 뒤, 특정 조회 기능에서 심각한 성능 저하가 발생할 경우, 해당 부분만 **선택적으로 반정규화를 적용**하는 트레이드오프 전략을 사용합니다.