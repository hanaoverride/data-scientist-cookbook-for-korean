# 1. NumPy: 파이썬 데이터 분석의 심장

## 목차
- [1. NumPy: 파이썬 데이터 분석의 심장](#1-numpy-파이썬-데이터-분석의-심장)
  - [목차](#목차)
  - [NumPy란? 왜 사용해야 하는가?](#numpy란-왜-사용해야-하는가)
  - [NumPy 배열(ndarray) 생성하기](#numpy-배열ndarray-생성하기)
  - [배열 다루기: 인덱싱, 슬라이싱, 형태 변경](#배열-다루기-인덱싱-슬라이싱-형태-변경)
  - [NumPy의 핵심: 벡터화 연산과 브로드캐스팅](#numpy의-핵심-벡터화-연산과-브로드캐스팅)
    - [벡터화 연산 (Vectorization)](#벡터화-연산-vectorization)
    - [브로드캐스팅 (Broadcasting)](#브로드캐스팅-broadcasting)
  - [데이터 분석의 기본기: 집계와 마스킹](#데이터-분석의-기본기-집계와-마스킹)
    - [집계 함수와 축(Axis)의 개념](#집계-함수와-축axis의-개념)
    - [마스킹 (Masking): 조건에 맞는 데이터만 골라내기](#마스킹-masking-조건에-맞는-데이터만-골라내기)

---

## NumPy란? 왜 사용해야 하는가?

**NumPy(Numerical Python)** 는 파이썬에서 대규모 다차원 배열과 행렬 연산을 빠르고 효율적으로 처리할 수 있도록 지원하는, **데이터 과학의 가장 근간이 되는** 핵심 라이브러리입니다. Pandas, Matplotlib, Scikit-learn 등 대부분의 데이터 과학 라이브러리들이 NumPy를 기반으로 만들어졌습니다.

- **왜 파이썬 리스트 대신 NumPy 배열을 사용할까?**
    1.  **압도적인 속도**: NumPy 배열은 내부적으로 C언어로 구현되어 있으며, 데이터를 메모리의 연속된 공간에 저장합니다. 이 덕분에 파이썬의 동적 타입 리스트보다 훨씬 빠르게 데이터를 처리할 수 있습니다.
    2.  **메모리 효율성**: 모든 원소가 동일한 데이터 타입으로 저장되므로, 각 원소마다 타입 정보를 저장할 필요가 없어 메모리를 훨씬 적게 사용합니다.
    3.  **강력한 기능**: 반복문(`for`) 없이도 전체 배열에 대해 연산을 수행하는 **벡터화(Vectorization)** 와, 형태가 다른 배열 간의 연산을 가능하게 하는 **브로드캐스팅(Broadcasting)**  등 강력한 기능을 제공합니다.

---

## NumPy 배열(ndarray) 생성하기

NumPy의 모든 기능은 `ndarray`(N-dimensional array)라는 자료구조를 기반으로 합니다. 관례적으로 `numpy`는 `np`라는 별칭으로 임포트합니다.

```python
import numpy as np

# 파이썬 리스트로부터 생성
arr1d = np.array([1, 2, 3, 4])       # 1차원 배열
arr2d = np.array([[1, 2], [3, 4]]) # 2차원 배열

# 특정 값으로 채워진 배열 생성
zeros = np.zeros((2, 3)) # 2x3 크기의, 모든 원소가 0인 배열
ones = np.ones(5)        # 크기가 5인, 모든 원소가 1인 배열

# 연속된 값으로 배열 생성
range_arr = np.arange(0, 10, 2) # 0부터 10 전까지 2씩 증가 -> [0, 2, 4, 6, 8]

# 난수로 배열 생성
rand_arr = np.random.rand(2, 3) # 0과 1 사이의 균등분포 난수로 2x3 배열 생성
```

---

## 배열 다루기: 인덱싱, 슬라이싱, 형태 변경

- **인덱싱/슬라이싱**: 파이썬 리스트와 유사하지만, 다차원 배열에서는 쉼표(`,`)를 사용하여 각 차원의 인덱스를 지정합니다.
- **형태 변경**: `reshape()` 메서드를 사용하여 배열의 차원과 모양을 바꿀 수 있습니다.

```python
arr = np.arange(1, 13).reshape(3, 4) # 1~12의 값을 가진 3x4 배열
# [[ 1,  2,  3,  4],
#  [ 5,  6,  7,  8],
#  [ 9, 10, 11, 12]]

# 인덱싱: 1행 2열의 값 (0부터 시작)
print(arr[1, 2]) # 7

# 슬라이싱: 0~1행과 1~2열의 부분 배열
print(arr[:2, 1:3])
# [[2, 3],
#  [6, 7]]
```

---

## NumPy의 핵심: 벡터화 연산과 브로드캐스팅

### 벡터화 연산 (Vectorization)

`for` 루프를 사용하지 않고, 배열의 모든 원소에 대해 산술 연산을 직접 수행하는 기능입니다. 코드가 간결해지고, 내부적으로 C로 처리되어 속도가 매우 빠릅니다.

```python
arr = np.array([1, 2, 3])

# for 루프 사용 (느림)
result_loop = []
for x in arr:
    result_loop.append(x * 2)

# 벡터화 연산 (빠름)
result_vec = arr * 2

print(result_vec) # [2 4 6]
```

### 브로드캐스팅 (Broadcasting)

서로 **형태(shape)가 다른 배열 간에도** 산술 연산이 가능하도록, NumPy가 부족한 차원이나 크기를 **자동으로 확장**해주는 기능입니다.

- **규칙**: 두 배열의 차원을 뒤에서부터 비교하여, (1) 차원의 크기가 같거나, (2) 둘 중 하나의 크기가 1일 때 브로드캐스팅이 가능합니다.

```python
# 3x3 배열과 1x3 배열의 덧셈
matrix = np.array([[0, 0, 0],
                   [10, 10, 10],
                   [20, 20, 20]])
vector = np.array([1, 2, 3])

# vector가 3x3으로 확장(복사)되어 각 행에 더해짐
result = matrix + vector
print(result)
# [[ 1,  2,  3],
#  [11, 12, 13],
#  [21, 22, 23]]
```

---

## 데이터 분석의 기본기: 집계와 마스킹

### 집계 함수와 축(Axis)의 개념

배열 전체 또는 특정 축(axis)을 기준으로 데이터를 요약하는 통계 함수입니다.

- **축 (Axis)** : 다차원 배열의 연산 방향을 지정합니다.
    - `axis=0`: **열** 방향으로 연산 (아래 방향으로 압축)
    - `axis=1`: **행** 방향으로 연산 (오른쪽 방향으로 압축)

```python
data = np.array([[1, 2, 3],
                 [4, 5, 6]])

print(data.sum())          # 전체 합: 21
print(data.sum(axis=0))    # 열 방향 합: [5, 7, 9]
print(data.sum(axis=1))    # 행 방향 합: [6, 15]
print(data.mean(axis=1))   # 행 방향 평균: [2., 5.]
```

### 마스킹 (Masking): 조건에 맞는 데이터만 골라내기

배열에 **조건식을 적용**하여 `True`/`False`로 이루어진 **불리언 배열(마스크)** 을 만들고, 이 마스크를 인덱스로 사용하여 `True`에 해당하는 원소만 추출하거나 수정하는 강력한 기능입니다.

```python
arr = np.arange(10) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 1. 마스크 생성
mask = arr > 5
print(mask) # [False, False, False, False, False, False,  True,  True,  True,  True]

# 2. 마스크를 이용한 필터링
print(arr[mask]) # [6, 7, 8, 9]

# 3. 마스크를 이용한 값 변경
# 짝수인 모든 원소를 0으로 변경
arr[arr % 2 == 0] = 0
print(arr) # [0, 1, 0, 3, 0, 5, 0, 7, 0, 9]
```