# 4. 그래프 탐색의 기초: DFS와 BFS

## 목차
- [4. 그래프 탐색의 기초: DFS와 BFS](#4-그래프-탐색의-기초-dfs와-bfs)
  - [목차](#목차)
  - [그래프(Graph)란?](#그래프graph란)
    - [그래프를 코드로 표현하는 법](#그래프를-코드로-표현하는-법)
  - [깊이 우선 탐색 (DFS): 막다른 길까지 깊게](#깊이-우선-탐색-dfs-막다른-길까지-깊게)
    - [DFS 구현하기: 재귀와 스택](#dfs-구현하기-재귀와-스택)
  - [너비 우선 탐색 (BFS): 가까운 곳부터 넓게](#너비-우선-탐색-bfs-가까운-곳부터-넓게)
    - [BFS 구현하기: 큐](#bfs-구현하기-큐)
  - [DFS vs. BFS: 언제 무엇을 쓸까?](#dfs-vs-bfs-언제-무엇을-쓸까)

---

## 그래프(Graph)란?

**그래프**는 **정점(Vertex 또는 노드)** 들과, 이 정점들을 연결하는 **간선(Edge)** 들로 구성된 자료구조입니다. 지하철 노선도처럼, 여러 지점(정점)들이 어떻게 연결되어 있는지(간선) 그 관계를 표현하는 데 사용됩니다.

### 그래프를 코드로 표현하는 법

1.  **인접 행렬 (Adjacency Matrix)** : `V x V` 크기의 2차원 배열로, `matrix[i][j]`가 1이면 `i`와 `j`가 연결되어 있음을 의미합니다.
    - **장점**: 두 정점의 연결 여부를 O(1)만에 바로 확인할 수 있습니다.
    - **단점**: 간선 수와 무관하게 항상 V²의 공간이 필요하여, 희소 그래프(간선이 적은 그래프)에서는 메모리 낭비가 심합니다.

2.  **인접 리스트 (Adjacency List)** : 각 정점마다, 해당 정점과 연결된 다른 정점들의 목록을 리스트로 저장합니다.
    - **장점**: 간선의 개수만큼만 공간을 차지하여 메모리 효율성이 좋습니다.
    - **단점**: 두 정점의 연결 여부를 확인하려면 리스트를 탐색해야 하므로, 인접 행렬보다 느릴 수 있습니다. (O(degree))

> **실무/코딩 테스트**: 대부분의 경우 간선의 수가 정점 수에 비해 훨씬 적은 **희소 그래프**이므로, **인접 리스트** 방식이 주로 사용됩니다.

---

## 깊이 우선 탐색 (DFS): 막다른 길까지 깊게

**DFS(Depth-First Search)** 는 시작 정점에서 출발하여, 한 방향으로 갈 수 있을 때까지 최대한 깊이 파고들다가, 더 이상 갈 곳이 없으면 가장 가까운 갈림길로 되돌아와 다른 방향을 탐색하는 방법입니다.

- **핵심 자료구조**: **스택(Stack)** . (재귀 함수 호출 시 내부적으로 사용되는 콜 스택 포함)
- **시간 복잡도**: O(V + E) (V: 정점 수, E: 간선 수, 인접 리스트 기준)

### DFS 구현하기: 재귀와 스택

```python
# graph는 인접 리스트로 표현됨
# graph = {1: [2, 3], 2: [4, 5], ...}

# 1. 재귀를 이용한 구현 (더 직관적)
visited = [False] * (V + 1)
def dfs_recursive(v):
    visited[v] = True # 방문 처리
    print(v, end=' ')
    for neighbor in graph[v]:
        if not visited[neighbor]:
            dfs_recursive(neighbor) # 인접 노드로 재귀 호출

# 2. 스택을 이용한 구현 (재귀 깊이가 너무 깊을 때 사용)
def dfs_stack(start_v):
    stack = [start_v]
    visited = [False] * (V + 1)
    while stack:
        v = stack.pop()
        if not visited[v]:
            visited[v] = True
            print(v, end=' ')
            # 인접 노드를 스택에 추가
            for neighbor in reversed(graph[v]): # 순서를 맞추기 위해 역순으로
                if not visited[neighbor]:
                    stack.append(neighbor)
```

---

## 너비 우선 탐색 (BFS): 가까운 곳부터 넓게

**BFS(Breadth-First Search)** 는 시작 정점에서 출발하여, 거리가 1인 정점들, 그다음 거리가 2인 정점들 순서로, 마치 물결이 퍼져나가듯 가까운 곳부터 순서대로 탐색하는 방법입니다.

- **핵심 자료구조**: **큐(Queue)** 
- **시간 복잡도**: O(V + E) (인접 리스트 기준)
- **특징**: **가중치가 없는 그래프**에서, 시작점으로부터 다른 모든 정점까지의 **최단 경로**를 찾는 데 사용됩니다.

### BFS 구현하기: 큐

```python
from collections import deque

def bfs(start_v):
    queue = deque([start_v])
    visited = [False] * (V + 1)
    visited[start_v] = True # 큐에 넣을 때 방문 처리

    while queue:
        v = queue.popleft() # 큐에서 꺼내서
        print(v, end=' ')   # 처리
        
        for neighbor in graph[v]:
            if not visited[neighbor]:
                visited[neighbor] = True # 방문 처리 후
                queue.append(neighbor)   # 큐에 넣음
```

---

## DFS vs. BFS: 언제 무엇을 쓸까?

| 구분 | DFS (깊이 우선) | BFS (너비 우선) |
|---|---|---|
| **자료구조** | 스택 (Stack), 재귀 | 큐 (Queue) |
| **속도** | 일반적으로 동일 (O(V+E)) | 일반적으로 동일 (O(V+E)) |
| **경로 탐색** | **경로의 특징**을 저장하는 데 유리 (예: 경로 자체) | **최단 경로**를 찾는 데 최적화 (가중치 없는 그래프) |
| **메모리** | 경로가 길어질수록 메모리 사용량 증가 (재귀 깊이) | 인접한 노드가 많을수록 메모리 사용량 증가 (큐 크기) |
| **주요 활용처** | 모든 조합 탐색, 사이클 탐지, 위상 정렬, 백트래킹 | 최단 거리 문제, 네트워크 브로드캐스팅 |

**선택 가이드**:
- **최단 거리를 찾아야 한다?** -> **BFS**
- **경로의 존재 여부만 확인하면 된다?** -> 구현이 간단한 **DFS**
- **모든 경우의 수를 탐색해야 한다?** -> **DFS** (백트래킹과 연계)
- **탐색 대상의 규모가 매우 크고, 답이 시작점 근처에 있을 것 같다?** -> **BFS**
- **탐색 대상의 규모가 매우 크고, 답이 깊은 곳에 있을 것 같다?** -> **DFS**