# 1. 알고리즘 효율성과 기초 알고리즘

## 목차
- [1. 알고리즘 효율성과 기초 알고리즘](#1-알고리즘-효율성과-기초-알고리즘)
  - [목차](#목차)
  - [알고리즘의 효율: 시간과 공간 복잡도](#알고리즘의-효율-시간과-공간-복잡도)
    - [시간 복잡도 (Time Complexity)](#시간-복잡도-time-complexity)
    - [공간 복잡도 (Space Complexity)](#공간-복잡도-space-complexity)
  - [기초 정수론 알고리즘](#기초-정수론-알고리즘)
    - [최대공약수: 유클리드 호제법](#최대공약수-유클리드-호제법)
    - [소수 판별: 에라토스테네스의 체](#소수-판별-에라토스테네스의-체)
  - [기초 문자열 알고리즘](#기초-문자열-알고리즘)
    - [팰린드롬 (Palindrome) 검사](#팰린드롬-palindrome-검사)
    - [올바른 괄호 검사](#올바른-괄호-검사)

---

## 알고리즘의 효율: 시간과 공간 복잡도

좋은 알고리즘이란 단순히 문제를 해결하는 것을 넘어, **정해진 시간과 메모리 자원 내에서** 효율적으로 동작하는 알고리즘을 의미합니다. 알고리즘의 효율성은 주로 **시간 복잡도**와 **공간 복잡도**로 평가합니다.

### 시간 복잡도 (Time Complexity)

**시간 복잡도**는 입력 데이터의 크기(N)가 증가함에 따라, 알고리즘의 **실행 시간(연산 횟수)이 얼마나 증가하는지**를 나타내는 척도입니다. **빅오(Big-O) 표기법**을 사용하여 최악의 경우를 기준으로 나타냅니다.

| 빅오 표기법 | 명칭 | 설명 | N=1,000,000일 때 대략적인 성능 |
|---|---|---|---|
| **O(1)**  | 상수 시간 | 데이터 크기와 상관없이 항상 실행 시간이 일정. | **가장 빠름** |
| **O(log N)**  | 로그 시간 | 데이터가 2배로 늘어도 실행 시간은 1단계만 증가. | 매우 빠름 |
| **O(N)**  | 선형 시간 | 데이터 크기와 실행 시간이 정비례. | 빠름 (약 100만 번 연산) |
| **O(N log N)**  | 로그 선형 시간 | 데이터 정렬에 사용되는 효율적인 알고리즘. | 충분히 빠름 (약 2,000만 번 연산) |
| **O(N²)**  | 이차 시간 | 이중 `for` 루프 구조. 데이터가 커지면 급격히 느려짐. | **느림** (약 1조 번 연산, 시간 초과) |
| **O(2ⁿ)**  | 지수 시간 | 모든 부분집합을 찾는 경우 등. N이 20만 넘어도 사용 불가. | 사용 불가 |

> **실전 감각**: 일반적인 코딩 테스트 환경(1초 시간제한)에서, 입력 크기(N)가 100만이라면, O(N log N) 이나 O(N) 시간 복잡도를 가진 알고리즘을 설계해야 통과할 수 있습니다.

### 공간 복잡도 (Space Complexity)

**공간 복잡도**는 입력 데이터의 크기(N)가 증가함에 따라, 알고리즘이 **필요로 하는 메모리 공간이 얼마나 증가하는지**를 나타내는 척도입니다.

---

## 기초 정수론 알고리즘

### 최대공약수: 유클리드 호제법

두 수의 **최대공약수(GCD, Greatest Common Divisor)** 를 매우 빠르게 구하는 알고리즘입니다. `a`를 `b`로 나눈 나머지를 `r`이라고 할 때, `GCD(a, b)`는 `GCD(b, r)`과 같다는 원리를 나머지가 0이 될 때까지 반복합니다.

- **시간 복잡도**: O(log N)

```python
def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

# 최소공배수(LCM)는 두 수의 곱을 최대공약수로 나누어 구함
def lcm(a, b):
    return (a * b) // gcd(a, b)
```

### 소수 판별: 에라토스테네스의 체

1부터 N까지의 모든 수 중에서 **소수(prime number)** 를 대량으로, 그리고 빠르게 찾아내는 알고리즘입니다.

- **원리**: 2부터 시작하여, 특정 숫자가 소수이면 그 수의 모든 배수를 '소수가 아님'으로 표시합니다. 이 과정을 N의 제곱근까지 반복합니다.
- **시간 복잡도**: O(N log log N)
- **공간 복잡도**: O(N)

```python
def sieve_of_eratosthenes(n):
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False

    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            # i의 배수들을 모두 False로 변경
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    
    return [num for num, prime in enumerate(is_prime) if prime]
```

---

## 기초 문자열 알고리즘

### 팰린드롬 (Palindrome) 검사

앞으로 읽으나 뒤로 읽으나 똑같은 문자열(예: "level", "토마토")인지 검사합니다.

- **방법 1 (간결함)** : 문자열을 뒤집어서 원본과 비교합니다.
  - `return s == s[::-1]`
- **방법 2 (투 포인터, 더 효율적)** : 양 끝에서 시작하는 두 개의 포인터(인덱스)를 중앙으로 이동시키며 문자를 비교합니다.
  - **시간 복잡도**: O(N), **공간 복잡도**: O(1)

```python
def is_palindrome(s: str) -> bool:
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

### 올바른 괄호 검사

`()`, `{}`, `[]` 와 같은 괄호들이 짝을 맞추어 올바르게 사용되었는지 검사합니다. **스택(Stack)**  자료구조를 활용하는 대표적인 문제입니다.

- **원리**:
    1. 여는 괄호를 만나면 스택에 `push`.
    2. 닫는 괄호를 만나면 스택에서 `pop`하여 짝이 맞는지 확인.
    3. 짝이 맞지 않거나, 닫는 괄호 차례에 스택이 비어있으면 실패.
    4. 모든 과정을 마친 후 스택이 비어있으면 성공.
- **시간 복잡도**: O(N), **공간 복잡도**: O(N)

```python
def is_valid_brackets(s: str) -> bool:
    stack = []
    bracket_map = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in bracket_map.values(): # 여는 괄호
            stack.append(char)
        elif char in bracket_map.keys(): # 닫는 괄호
            if not stack or stack.pop() != bracket_map[char]:
                return False
        # 괄호가 아닌 문자는 무시
    
    return not stack # 스택이 비어있으면 True
```