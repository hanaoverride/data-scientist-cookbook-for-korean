# 7. 특이값 분해(SVD)와 머신러닝 응용 📚

## 목차 📑

### 1. 특이값 분해 예제
- [1.1 PSD 행렬과 고유값](#psd-행렬과-고유값-) 🟩
- [1.2 SVD 계산 예시](#svd-계산-예시-) 🧮

### 2. 특이값 분해 이론
- [2.1 SVD의 정의와 성질](#svd의-정의와-성질-) 📐
- [2.2 SVD의 행렬 분해 과정](#svd의-행렬-분해-과정-) 🔬

### 3. SVD의 머신러닝 응용
- [3.1 SVD와 차원 축소](#svd와-차원-축소-) 📉
- [3.2 SVD를 활용한 영상 압축](#svd를-활용한-영상-압축-) 🖼️

---

## PSD 행렬과 고유값 🟩

**양의 준정부호 행렬(Positive Semi-Definite Matrix, PSD)**은 모든 벡터 x에 대해 xᵀAx ≥ 0을 만족하는 **대칭 행렬**을 의미한다. 이러한 행렬은 **고유값**이 모두 0 이상이며, 행렬의 여러 성질과 등가 조건이 존재한다.

- **동치 조건**:
  1. 행렬 A가 PSD이다.
  2. 모든 고유값이 0 이상이다.
  3. 어떤 행렬 B가 존재하여 A = BᵀB로 표현된다.
  4. 모든 부분행렬식이 0 이상이다.

대칭 행렬의 경우, **고유벡터**는 서로 직교하며, **정규 직교 행렬**을 이용해 대각화가 가능하다.

```python
import numpy as np

# 임의의 2x2 PSD 행렬 생성
A = np.array([[3, 1],
              [1, 2]])

# 고유값과 고유벡터 계산
eigvals, eigvecs = np.linalg.eigh(A)
print("고유값:", eigvals)
print("고유벡터:\n", eigvecs)
```

**출력 예시**:
```
고유값: [1.38196601 3.61803399]
고유벡터:
 [[-0.85065081  0.52573111]
  [ 0.52573111  0.85065081]]
```

> ⚠️ **주의사항**: PSD 행렬이 아닌 경우, 고유값 중 음수가 존재할 수 있으므로 반드시 대칭성과 고유값 조건을 확인해야 한다.

---

## SVD 계산 예시 🧮

**특이값 분해(Singular Value Decomposition, SVD)**는 임의의 m×n 행렬 A를 세 개의 행렬 곱으로 분해하는 방법이다. SVD는 다음과 같이 표현된다:

A = UΣVᵀ

여기서 **U**는 m×m 직교 행렬, **Σ**는 m×n 대각 행렬(특이값이 대각선에 위치), **V**는 n×n 직교 행렬이다.

```python
import numpy as np

# 3x2 임의 행렬 생성
B = np.array([[2, 0],
              [0, 1],
              [1, 1]])

# SVD 분해
U, S, VT = np.linalg.svd(B, full_matrices=False)
print("U 행렬:\n", U)
print("특이값(Σ):", S)
print("V^T 행렬:\n", VT)
```

**출력 예시**:
```
U 행렬:
 [[-0.8944  0.3586]
 [ 0.3586  0.8944]
 [-0.2673  0.2673]]
특이값(Σ): [2.2361 1.0000]
V^T 행렬:
 [[-0.8944 -0.4472]
 [ 0.4472 -0.8944]]
```

> ⚠️ **주의사항**: SVD 계산 결과의 특이값은 항상 0 이상의 실수이며, 행렬의 rank에 따라 0이 아닌 특이값의 개수가 결정된다.

---

## SVD의 정의와 성질 📐

**특이값 분해(SVD)**는 임의의 실수 또는 복소수 행렬 A(m×n)에 대해 다음과 같이 분해할 수 있음을 의미한다:

A = UΣVᵀ

- **U**: m×m 직교 행렬 (UᵀU = I)
- **Σ**: m×n 대각 행렬, 대각선에 **특이값(singular value)**이 위치
- **V**: n×n 직교 행렬 (VᵀV = I)

특이값은 A의 고유값과 밀접한 관련이 있으며, AᵀA 또는 AAᵀ의 고유값의 제곱근으로 정의된다. SVD는 모든 행렬에 대해 항상 존재하며, 대칭 행렬의 경우 고유값 분해와 밀접하게 연결된다.

```python
import numpy as np

# 4x3 임의 행렬 생성
C = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9],
              [1, 3, 5]])

U, S, VT = np.linalg.svd(C, full_matrices=False)
print("특이값:", S)
```

**출력 예시**:
```
특이값: [17.2906  1.2312  0.2077]
```

> ⚠️ **주의사항**: 특이값의 개수는 min(m, n)개이며, 특이값이 0에 가까울수록 해당 차원의 정보량이 적음을 의미한다.

---

## SVD의 행렬 분해 과정 🔬

SVD의 행렬 분해는 다음과 같은 수학적 성질을 기반으로 한다:

- AᵀA와 AAᵀ는 각각 n×n, m×m의 **대칭 행렬**이며, 이들의 고유값은 모두 0 이상의 실수이다.
- AᵀA의 고유벡터로부터 **V**를, AAᵀ의 고유벡터로부터 **U**를 구할 수 있다.
- **특이값**은 AᵀA 또는 AAᵀ의 고유값의 제곱근이다.

이 과정을 통해 임의의 행렬을 직교 행렬과 대각 행렬의 곱으로 분해할 수 있다.

```python
import numpy as np

# 2x2 임의 행렬
D = np.array([[4, 0],
              [3, -5]])

# AᵀA 계산 및 고유값, 고유벡터
ATA = D.T @ D
eigvals, eigvecs = np.linalg.eigh(ATA)
singular_values = np.sqrt(np.abs(eigvals))
print("AᵀA:\n", ATA)
print("고유값:", eigvals)
print("특이값:", singular_values)
```

**출력 예시**:
```
AᵀA:
 [[25  0]
 [ 0 25]]
고유값: [25. 25.]
특이값: [5. 5.]
```

> ⚠️ **주의사항**: SVD의 각 행렬(U, Σ, V)은 고유값 분해와 달리 항상 실수 직교 행렬로 구성되며, 행렬의 크기에 따라 full/축소 형태로 반환될 수 있다.

---

## SVD와 차원 축소 📉

**SVD**는 데이터의 **차원 축소(dimension reduction)**에 매우 효과적으로 사용된다. 행렬의 rank가 1인 경우, 두 벡터의 외적(outer product)으로 전체 행렬을 표현할 수 있다. 일반적인 행렬은 여러 rank-1 행렬의 합으로 근사할 수 있으며, 주요 특이값만을 사용해 원본 행렬을 압축할 수 있다.

예를 들어, n×n 행렬을 두 벡터의 외적으로 표현하면 2n개의 값만으로 전체 정보를 근사할 수 있다. 이는 데이터 저장 공간을 크게 줄이는 효과가 있다.

```python
import numpy as np

# 5x5 임의 행렬 생성
E = np.outer([1, 2, 3, 4, 5], [2, 4, 6, 8, 10])
print("Rank 1 행렬:\n", E)
```

**출력 예시**:
```
Rank 1 행렬:
[[ 2  4  6  8 10]
 [ 4  8 12 16 20]
 [ 6 12 18 24 30]
 [ 8 16 24 32 40]
 [10 20 30 40 50]]
```

> ⚠️ **주의사항**: 모든 행렬이 rank-1로 표현되지는 않으며, 일반적으로 여러 개의 rank-1 행렬의 합으로 근사한다. 특이값이 급격히 감소하는 경우, 상위 몇 개만 사용해도 원본 행렬을 잘 근사할 수 있다.

---

## SVD를 활용한 영상 압축 🖼️

**영상 압축**에서 SVD는 이미지 행렬을 주요 특이값과 대응하는 벡터만으로 근사하여 저장 공간을 크게 줄일 수 있다. 예를 들어, m×n 크기의 흑백 이미지를 SVD로 분해한 뒤 상위 k개의 특이값만 사용하면, 원본 대비 훨씬 적은 수의 값으로 이미지를 복원할 수 있다.

- 원본 데이터 크기: m×n
- SVD 압축 데이터 크기: k×(m + n + 1) (k는 사용 특이값 개수)

```python
import numpy as np
import matplotlib.pyplot as plt

# 임의의 50x50 이미지 생성
np.random.seed(0)
img = np.random.rand(50, 50)

# SVD 분해
U, S, VT = np.linalg.svd(img, full_matrices=False)

# 상위 5개 특이값만 사용해 복원
k = 5
img_approx = U[:, :k] @ np.diag(S[:k]) @ VT[:k, :]

# 시각화
plt.subplot(1, 2, 1)
plt.title('원본 이미지')
plt.imshow(img, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title(f'SVD 압축 (k={k})')
plt.imshow(img_approx, cmap='gray')
plt.axis('off')
plt.show()
```

**출력 예시**:  
왼쪽은 원본 이미지, 오른쪽은 SVD로 압축한 이미지로, 주요 정보는 유지되면서 데이터 크기가 크게 줄어든다.

> ⚠️ **주의사항**: 압축에 사용할 k값이 너무 작으면 이미지 품질이 급격히 저하될 수 있다. k값 선택은 품질과 압축률의 균형을 고려해야 한다.

