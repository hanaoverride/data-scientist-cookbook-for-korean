# 4. 벡터공간과 부분공간 ✨

## 목차 📑

### 1. 벡터 개념의 시작
- [1.1 벡터의 정의와 기하학적 의미](#벡터의-정의와-기하학적-의미-) 🏹
- [1.2 벡터의 연산과 성질](#벡터의-연산과-성질-) ➕

### 2. 벡터공간과 Rⁿ
- [2.1 벡터공간의 개념](#벡터공간의-개념-) 🌌
- [2.2 Rⁿ의 정의와 연산](#rⁿ의-정의와-연산-) 🔢
- [2.3 벡터 표기법](#벡터-표기법-) ✍️

### 3. 벡터의 내적과 노름
- [3.1 내적과 벡터의 크기](#내적과-벡터의-크기-) 📏
- [3.2 거리와 노름의 정의](#거리와-노름의-정의-) 📐
- [3.3 내적의 성질과 연산법칙](#내적의-성질과-연산법칙-) ⚖️
- [3.4 주요 부등식과 정리](#주요-부등식과-정리-) 🧮
- [3.5 벡터 사이의 각과 수직성](#벡터-사이의-각과-수직성-) ⦜

---

## 벡터의 정의와 기하학적 의미 🏹

**설명**  
**벡터**는 크기와 방향을 동시에 가지는 수학적 객체로, 물리학에서는 속도, 힘, 가속도 등 다양한 현상을 표현하는 데 사용된다. 벡터는 일반적으로 화살표로 시각화하며, 시작점과 끝점, 그리고 길이로 각각 위치와 크기를 나타낸다. 벡터의 개념은 기하학적 의미뿐 아니라, 데이터 분석과 머신러닝 등 현대 과학기술 분야에서 핵심적인 역할을 한다.

**예시**
```python
# 2차원 평면에서 벡터를 시각화하는 예시
import matplotlib.pyplot as plt

start = [0, 0]
vector = [3, 2]

plt.quiver(*start, *vector, angles='xy', scale_units='xy', scale=1, color='blue')
plt.xlim(-1, 5)
plt.ylim(-1, 4)
plt.grid()
plt.title("2차원 벡터 시각화")
plt.show()
```

**주의사항**  
벡터는 방향성을 가지므로, 동일한 크기라도 방향이 다르면 서로 다른 벡터로 간주한다. 평행이동으로 겹칠 수 있으면 같은 벡터로 본다.

---

## 벡터의 연산과 성질 ➕

**설명**  
벡터는 **덧셈**과 **스칼라 곱셈** 연산이 정의된다. 두 벡터의 덧셈은 평행사변형 법칙 또는 꼬리-머리 연결법으로 시각화할 수 있다. 스칼라 곱셈은 벡터의 크기를 변화시키되 방향은 유지한다.

**예시**
```python
# 벡터 덧셈과 스칼라 곱셈 예시
import numpy as np

v1 = np.array([2, 1])
v2 = np.array([1, 3])
sum_vec = v1 + v2        # 벡터 덧셈
scaled_vec = 2 * v1      # 스칼라 곱셈

print("벡터 덧셈:", sum_vec)      # [3 4]
print("스칼라 곱셈:", scaled_vec) # [4 2]
```

**주의사항**  
벡터의 덧셈은 교환법칙과 결합법칙이 성립한다. 스칼라 곱셈은 실수와 벡터의 곱으로, 크기만 변하고 방향은 변하지 않는다.

---

## 벡터공간의 개념 🌌

**설명**  
**벡터공간**은 벡터와 스칼라(실수) 사이의 두 연산(덧셈, 스칼라 곱셈)이 정의되고, 이 연산들이 특정 공리(교환법칙, 결합법칙, 항등원, 역원 등)를 만족하는 집합이다. 벡터공간은 물리적 공간에 한정되지 않고, n차원의 추상적 공간까지 확장된다.

**예시**
```python
# 3차원 벡터공간에서 벡터 덧셈과 스칼라 곱셈
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 0, -1])
scalar = 3

sum_ab = a + b
scaled_a = scalar * a

print("벡터 덧셈:", sum_ab)      # [5 2 2]
print("스칼라 곱셈:", scaled_a)  # [3 6 9]
```

**주의사항**  
벡터공간의 원소는 반드시 같은 차원을 가져야 하며, 연산 결과도 동일한 차원의 벡터가 되어야 한다.

---

## Rⁿ의 정의와 연산 🔢

**설명**  
**Rⁿ**은 n개의 실수로 이루어진 순서쌍(튜플)들의 집합이다. R²는 2차원 평면, R³는 3차원 공간을 의미하며, 일반적으로 Rⁿ은 n차원 벡터공간을 나타낸다. 이 공간에서 벡터의 덧셈과 스칼라 곱셈이 정의된다.

**예시**
```python
# 4차원 벡터공간에서의 연산 예시
import numpy as np

x = np.array([1, 2, 3, 4])
y = np.array([0, -1, 2, 1])
alpha = 0.5

sum_xy = x + y
scaled_y = alpha * y

print("벡터 덧셈:", sum_xy)      # [1 1 5 5]
print("스칼라 곱셈:", scaled_y)  # [ 0.  -0.5  1.   0.5]
```

**주의사항**  
덧셈과 스칼라 곱셈은 각각 Rⁿ 내에서 닫혀 있어야 하며, 연산 결과가 항상 Rⁿ의 원소가 되어야 한다.

---

## 벡터 표기법 ✍️

**설명**  
벡터는 일반적으로 소문자 굵은체 또는 화살표로 표기한다. 행벡터는 (x₁, x₂, ..., xₙ) 형태, 열벡터는 세로로 나열된 형태로 나타낸다. 전치 연산(`.T` 또는 `⊤`)을 통해 행벡터와 열벡터를 변환할 수 있다.

**예시**
```python
import numpy as np

v = np.array([5, -2, 7])
v_row = v           # 행벡터
v_col = v.reshape(-1, 1)  # 열벡터

print("행벡터:", v_row)
print("열벡터:\n", v_col)
```

**주의사항**  
벡터의 표기 방식에 따라 연산 결과가 달라질 수 있으므로, 행/열 벡터 구분에 유의해야 한다.

---

## 내적과 벡터의 크기 📏

**설명**  
**내적(Inner product)**은 두 벡터의 대응 원소를 곱한 뒤 모두 더하는 연산이다. 내적을 통해 벡터의 크기(노름)와 두 벡터 사이의 각도를 계산할 수 있다. 벡터의 크기는 자기 자신과의 내적의 제곱근으로 정의된다.

**예시**
```python
import numpy as np

u = np.array([2, -1, 4])
v = np.array([1, 3, 0])

dot_product = np.dot(u, v)      # 내적
norm_u = np.linalg.norm(u)      # 벡터의 크기

print("내적:", dot_product)     # 2*1 + (-1)*3 + 4*0 = -1
print("벡터의 크기:", norm_u)   # sqrt(2^2 + (-1)^2 + 4^2) = sqrt(21)
```

**주의사항**  
내적은 두 벡터의 차원이 같을 때만 정의된다. 내적 결과가 0이면 두 벡터는 서로 수직이다.

---

## 거리와 노름의 정의 📐

**설명**  
**노름(Norm)**은 벡터의 크기를 측정하는 함수이며, **거리(Metric)**는 두 점(벡터) 사이의 간격을 나타낸다. 대표적인 노름으로 L₁, L₂, L∞ 노름이 있으며, L₂ 노름은 유클리드 거리와 동일하다.  
거리 함수는 비음수성, 항등성, 대칭성, 삼각부등식의 네 가지 조건을 만족해야 한다.

**예시**
```python
import numpy as np

a = np.array([1, -2, 3])
b = np.array([4, 0, -1])

l1_norm = np.sum(np.abs(a))
l2_norm = np.linalg.norm(a)
linf_norm = np.max(np.abs(a))

euclidean_distance = np.linalg.norm(a - b)

print("L1 노름:", l1_norm)             # 6
print("L2 노름:", l2_norm)             # sqrt(14)
print("L∞ 노름:", linf_norm)           # 3
print("유클리드 거리:", euclidean_distance) # sqrt((1-4)^2 + (-2-0)^2 + (3+1)^2)
```

**주의사항**  
노름과 거리는 유사하지만, 노름은 벡터의 크기, 거리는 두 벡터 사이의 간격을 의미한다. p값에 따라 다양한 거리/노름이 정의된다.

---

## 내적의 성질과 연산법칙 ⚖️

**설명**  
내적은 다음과 같은 성질을 가진다:
- **선형성**: ⟨a + b, c⟩ = ⟨a, c⟩ + ⟨b, c⟩
- **대칭성**: ⟨a, b⟩ = ⟨b, a⟩
- **양의 정부호성**: ⟨a, a⟩ ≥ 0, ⟨a, a⟩ = 0 ⇔ a = 0

또한, 벡터의 크기와 내적을 활용한 여러 정리(피타고라스, 평행사변형 등)가 존재한다.

**예시**
```python
import numpy as np

x = np.array([2, 1])
y = np.array([-1, 3])

# 피타고라스 정리 검증
left = np.linalg.norm(x + y)**2
right = np.linalg.norm(x)**2 + np.linalg.norm(y)**2 + 2 * np.dot(x, y)

print("좌변:", left)
print("우변:", right)
```

**주의사항**  
내적의 성질을 활용할 때, 벡터의 차원과 연산 순서에 주의해야 한다.

---

## 주요 부등식과 정리 🧮

**설명**  
- **Cauchy-Schwarz 부등식**: 임의의 벡터 v, w에 대해 |⟨v, w⟩| ≤ ||v||·||w||가 성립한다. 등호는 두 벡터가 일직선상에 있을 때만 성립한다.
- **삼각부등식**: ||v + w|| ≤ ||v|| + ||w||가 항상 성립한다.
- **피타고라스 정리**: 두 벡터가 수직일 때, ||v + w||² = ||v||² + ||w||²가 성립한다.

**예시**
```python
import numpy as np

v = np.array([1, 2, 2])
w = np.array([2, -1, 0])

# Cauchy-Schwarz 부등식 검증
inner = np.abs(np.dot(v, w))
product_norms = np.linalg.norm(v) * np.linalg.norm(w)

print("내적 절댓값:", inner)
print("노름 곱:", product_norms)
print("부등식 성립:", inner <= product_norms)
```

**주의사항**  
Cauchy-Schwarz 부등식은 벡터 공간에서 매우 중요한 불평등이며, 벡터의 각도 정의 등 다양한 곳에 활용된다.

---

## 벡터 사이의 각과 수직성 ⦜

**설명**  
두 벡터 사이의 **각도**는 내적을 이용해 정의된다.  
cosθ = ⟨v, w⟩ / (||v||·||w||)  
이때 θ는 [0, π] 범위의 유일한 값이다.  
특히, 내적이 0이면 두 벡터는 서로 **수직(직교)**이다.

**예시**
```python
import numpy as np

a = np.array([1, 0])
b = np.array([0, 2])

cos_theta = np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))
theta = np.arccos(cos_theta)

print("cosθ:", cos_theta)  # 0
print("각도(라디안):", theta)  # π/2
```

**주의사항**  
벡터의 크기가 0인 경우 각도 계산이 불가능하므로, 반드시 두 벡터가 영벡터가 아닌지 확인해야 한다.

