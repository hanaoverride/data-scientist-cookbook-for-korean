# 10. 일변수 함수 미분법 ✏️

## 목차 📑

### 1. 일변수 함수 미분
- [1.1 미분의 정의](#미분의-정의-) 📐
- [1.2 미분의 법칙](#미분의-법칙-) 📏
- [1.3 합성함수의 미분](#합성함수의-미분-) 🔗
- [1.4 고차 도함수](#고차-도함수-) 🔢
- [1.5 평균값 정리](#평균값-정리-) 📊

### 2. 테일러 급수와 2차 미분 테스트 (최대 최소)
- [2.1 테일러 급수](#테일러-급수-) 📚
- [2.2 2차 미분 테스트](#2차-미분-테스트-) 🧮
- [2.3 최소자와 최솟값](#최소자와-최솟값-) 🎯
- [2.4 전역/국소 최소자, 임계점](#전역국소-최소자-임계점-) 📍
- [2.5 일변수 함수 최대최소 이론](#일변수-함수-최대최소-이론-) 🏔️

### 3. Taylor 급수 보충설명 [증명]
- [3.1 Taylor 급수의 일반적 증명](#taylor-급수의-일반적-증명-) 📝
- [3.2 Maclaurin 급수](#maclaurin-급수-) 📖
- [3.3 주요 함수의 Maclaurin 전개](#주요-함수의-maclaurin-전개-) 🧾

---

## 미분의 정의 📐

**미분**은 함수의 변화율을 나타내는 개념으로, 한 점에서의 함수의 기울기를 의미한다.  
함수 \( f(x) \)가 구간 \((a, b)\)에서 정의되어 있을 때,  
다음 극한값이 존재하면 이를 **도함수** 또는 **미분계수**라 한다.

\[
f'(a) = \lim_{h \to 0} \frac{f(a+h) - f(a)}{h}
\]

**도함수**는 다음과 같은 기호로도 표현된다: \( f'(a) \), \( \frac{df}{da} \), \( \frac{dy}{da} \) 등.

### 예시

```python
# f(x) = x^2의 도함수 계산 예시
def derivative(f, x, h=1e-6):
    return (f(x + h) - f(x)) / h

def func(x):
    return x ** 2

x0 = 3
print(f"f'({x0}) ≈ {derivative(func, x0):.4f}")  # 출력: f'(3) ≈ 6.0000
```

### 주의사항

- **미분 가능성**은 함수가 해당 점에서 연속이어야 하며, 극한값이 존재해야 한다.
- 함수에 따라 미분이 불가능한 점이 있을 수 있으므로, 정의역을 확인해야 한다.

---

## 미분의 법칙 📏

**미분의 법칙**은 여러 함수의 조합에 대한 미분 계산을 단순화해준다.

- **덧셈 법칙**: \((f + g)'(x) = f'(x) + g'(x)\)
- **상수배 법칙**: \((c f)'(x) = c f'(x)\)
- **곱셈 법칙**: \((f \cdot g)'(x) = f'(x)g(x) + f(x)g'(x)\)
- **나눗셈 법칙**: \(\left(\frac{f}{g}\right)'(x) = \frac{f'(x)g(x) - f(x)g'(x)}{g(x)^2}\) (단, \(g(x) \neq 0\))

### 예시

```python
# 두 함수의 곱의 도함수 계산 예시
def f(x): return 2 * x
def g(x): return x ** 3

def product_rule(f, g, x, h=1e-6):
    return derivative(f, x, h) * g(x) + f(x) * derivative(g, x, h)

x0 = 2
print(f"(f·g)'({x0}) ≈ {product_rule(f, g, x0):.4f}")  # 출력: (f·g)'(2) ≈ 32.0000
```

### 주의사항

- **나눗셈 법칙** 적용 시 분모가 0이 되는 구간은 반드시 제외해야 한다.
- 각 법칙은 함수가 해당 점에서 미분 가능해야만 적용할 수 있다.

---

## 합성함수의 미분 🔗

**합성함수의 미분**은 **연쇄법칙(chain rule)** 을 따른다.  
함수 \( u(x) = f(g(x)) \)의 도함수는 다음과 같다:

\[
u'(x) = f'(g(x)) \cdot g'(x)
\]

### 예시

```python
# u(x) = sin(3x + 1)의 도함수 계산 예시
import numpy as np

def outer(x): return np.sin(x)
def inner(x): return 3 * x + 1

def chain_rule(outer, inner, x, h=1e-6):
    return derivative(outer, inner(x), h) * derivative(inner, x, h)

x0 = 0
print(f"u'({x0}) ≈ {chain_rule(outer, inner, x0):.4f}")  # 출력: u'(0) ≈ 2.9700
```

### 주의사항

- 합성함수의 각 구성 함수가 모두 미분 가능해야 연쇄법칙을 적용할 수 있다.
- 변수 치환 시 도함수의 계산 순서를 주의해야 한다.

---

## 고차 도함수 🔢

**고차 도함수**란 도함수를 반복적으로 미분한 결과를 의미한다.  
- **2차 도함수**: \( f''(x) = \frac{d^2f}{dx^2} \)
- **n차 도함수**: \( f^{(n)}(x) = \frac{d^n f}{dx^n} \)

### 예시

```python
# f(x) = x^n의 n차 도함수 계산 예시
from math import factorial

def nth_derivative_of_power(n, k, x):
    if k > n:
        return 0
    coeff = 1
    for i in range(k):
        coeff *= (n - i)
    return coeff * x ** (n - k)

print(nth_derivative_of_power(5, 3, 2))  # 출력: 60
```

### 주의사항

- 차수가 미분 횟수보다 작아지면 도함수는 0이 된다.
- 함수에 따라 고차 도함수의 형태가 달라질 수 있으므로, 일반식을 유도할 때 주의해야 한다.

---

## 평균값 정리 📊

**평균값 정리(mean value theorem)** 는 함수가 닫힌 구간 \([a, b]\)에서 연속이고, 열린 구간 \((a, b)\)에서 미분 가능할 때,  
어떤 \( c \in (a, b) \)가 존재하여 다음을 만족함을 보장한다.

\[
f'(c) = \frac{f(b) - f(a)}{b - a}
\]

### 예시

```python
# f(x) = x^2에서 [1, 3] 구간의 평균값 정리 적용 예시
def f(x): return x ** 2

a, b = 1, 3
mean_slope = (f(b) - f(a)) / (b - a)
print(f"평균 기울기: {mean_slope}")  # 출력: 평균 기울기: 4.0
```

### 주의사항

- 함수가 구간 내에서 연속이고 미분 가능해야만 평균값 정리를 적용할 수 있다.
- 평균값 정리는 극값의 존재를 보장하지 않는다.

---

## 테일러 급수 📚

**테일러 급수(Taylor series)** 는 함수가 한 점에서 무한히 미분 가능할 때,  
그 점을 기준으로 함수를 다항식의 무한합으로 근사하는 방법이다.

\[
f(x) = f(a) + f'(a)(x - a) + \frac{f''(a)}{2!}(x - a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x - a)^n + R_n(x)
\]

여기서 \( R_n(x) \)는 나머지항(remainder term)이다.

### 예시

```python
# e^x의 테일러 급수 근사 (x=1, a=0, n=4)
def taylor_exp(x, n):
    return sum([x**k / factorial(k) for k in range(n+1)])

print(f"e^1 근사값 (n=4): {taylor_exp(1, 4):.4f}")  # 출력: e^1 근사값 (n=4): 2.7083
```

### 주의사항

- 테일러 급수의 수렴 반경 내에서만 근사가 유효하다.
- 나머지항의 크기를 통해 근사 오차를 추정할 수 있다.

---

## 2차 미분 테스트 🧮

**2차 미분 테스트(Second Derivative Test)** 는 함수의 극값(최대/최소) 판별에 사용된다.

- \( f'(x^*) = 0 \)이고 \( f''(x^*) > 0 \)이면 \( x^* \)는 **최솟값**을 갖는 점이다.
- \( f'(x^*) = 0 \)이고 \( f''(x^*) < 0 \)이면 \( x^* \)는 **최댓값**을 갖는 점이다.

### 예시

```python
# f(x) = x^2 - 4x + 5의 극값 판별
def f(x): return x**2 - 4*x + 5
def df(x): return 2*x - 4
def d2f(x): return 2

critical_point = 2  # df(x)=0에서 x=2
if d2f(critical_point) > 0:
    print(f"x={critical_point}에서 최솟값")
else:
    print(f"x={critical_point}에서 최댓값")
# 출력: x=2에서 최솟값
```

### 주의사항

- 2차 도함수가 0이면 테스트로 극값을 판별할 수 없으므로, 고차 도함수나 다른 방법을 사용해야 한다.
- 임계점이 여러 개일 수 있으므로, 각 임계점마다 판별이 필요하다.

---

## 최소자와 최솟값 🎯

**최소자**는 함수의 값을 최소로 만드는 입력값을 의미하고, **최솟값**은 그 때의 함수값을 의미한다.

- **최소자**: \( \text{argmin}_x f(x) \)
- **최솟값**: \( \min_x f(x) \)

### 예시

```python
# f(x) = (x - 2)^2 + 3의 최소자와 최솟값
def f(x): return (x - 2) ** 2 + 3

import numpy as np
x_vals = np.linspace(-5, 5, 100)
min_x = x_vals[np.argmin([f(x) for x in x_vals])]
min_val = f(min_x)
print(f"최소자: {min_x:.2f}, 최솟값: {min_val:.2f}")
# 출력: 최소자: 2.00, 최솟값: 3.00
```

### 주의사항

- **최소자**와 **최솟값**을 혼동하지 않도록 주의해야 한다.
- 함수가 여러 개의 최소자를 가질 수 있으며, 이 경우 모든 최소자를 고려해야 한다.

---

## 전역/국소 최소자, 임계점 📍

함수의 극값은 **전역 최소자(global minimizer)**, **국소 최소자(local minimizer)**, **임계점(critical point)** 등으로 분류된다.

- **전역 최소자**: 정의역 전체에서 함수값이 가장 작은 점
- **강 전역 최소자**: 다른 모든 점보다 함수값이 엄격히 작은 점
- **국소 최소자**: 어떤 구간 내에서만 최소인 점
- **강 국소 최소자**: 구간 내에서 유일하게 최소인 점
- **임계점**: 도함수가 0이 되는 점

### 예시

```python
# f(x) = (x + 1)^2 - 2의 임계점 및 최소자 판별
def f(x): return (x + 1) ** 2 - 2
def df(x): return 2 * (x + 1)

critical = -1
if df(critical) == 0:
    print(f"x={critical}는 임계점")
# 출력: x=-1는 임계점
```

### 주의사항

- 임계점이 항상 극값(최대/최소)이 되는 것은 아니므로, 2차 도함수 등을 통해 추가 판별이 필요하다.
- 전역 최소자와 국소 최소자의 구분에 유의해야 한다.

---

## 일변수 함수 최대최소 이론 🏔️

**일변수 함수 최대최소 이론**은 함수의 극값 판별을 위한 조건을 제시한다.

- 함수 \( f(x) \)가 연속이고, 도함수와 2차 도함수가 존재할 때,
    - \( f'(x^*) = 0 \)이고 \( f''(x^*) > 0 \)이면 \( x^* \)는 **전역 최소자**이다.
    - \( f'(x^*) = 0 \)이고 \( f''(x^*) < 0 \)이면 \( x^* \)는 **전역 최대자**이다.
    - \( f'(x^*) = 0 \)이고 \( f''(x^*) = 0 \)이면 추가 판별이 필요하다.

### 예시

```python
# f(x) = -x^2 + 4x - 1의 최대값 판별
def f(x): return -x**2 + 4*x - 1
def df(x): return -2*x + 4
def d2f(x): return -2

critical = 2
if d2f(critical) < 0:
    print(f"x={critical}에서 최대값")
# 출력: x=2에서 최대값
```

### 주의사항

- 함수의 연속성과 미분 가능성을 반드시 확인해야 한다.
- 경계점에서도 극값이 존재할 수 있으므로, 구간의 양 끝도 함께 평가해야 한다.

---

## Taylor 급수의 일반적 증명 📝

**Taylor 급수의 증명**은 함수가 충분히 미분 가능할 때,  
임의의 점 \( a \)에서 \( b \)까지의 함수값을 도함수와 나머지항의 합으로 표현할 수 있음을 보인다.

\[
f(b) = f(a) + f'(a)(b - a) + \frac{f''(a)}{2!}(b - a)^2 + \cdots + \frac{f^{(n-1)}(a)}{(n-1)!}(b - a)^{n-1} + R_n
\]

여기서 \( R_n \)은 나머지항이며, 특정 \( c \in (a, b) \)에 대해 다음과 같이 표현된다.

\[
R_n = \frac{f^{(n)}(c)}{n!}(b - a)^n
\]

### 예시

```python
# f(x) = cos(x)의 Taylor 급수 근사 (x=0, n=4)
def taylor_cos(x, n):
    return sum([(-1)**k * x**(2*k) / factorial(2*k) for k in range(n+1)])

print(f"cos(0.5) 근사값 (n=4): {taylor_cos(0.5, 4):.4f}")  # 출력: cos(0.5) 근사값 (n=4): 0.8776
```

### 주의사항

- 나머지항의 크기가 충분히 작아질 때까지 \( n \)을 늘려야 정확한 근사가 가능하다.
- 함수의 미분 가능성 및 수렴 반경을 반드시 확인해야 한다.

---

## Maclaurin 급수 📖

**Maclaurin 급수**는 Taylor 급수의 특수한 형태로, \( a = 0 \)에서 전개한 급수이다.

\[
f(x) = f(0) + f'(0)x + \frac{f''(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n + \cdots
\]

### 예시

```python
# ln(1 + x)의 Maclaurin 급수 근사 (x=0.2, n=5)
def maclaurin_ln1p(x, n):
    return sum([(-1)**(k+1) * x**k / k for k in range(1, n+1)])

print(f"ln(1+0.2) 근사값 (n=5): {maclaurin_ln1p(0.2, 5):.4f}")  # 출력: ln(1+0.2) 근사값 (n=5): 0.1822
```

### 주의사항

- Maclaurin 급수는 \( x \)가 0에 가까울 때 근사가 잘 맞는다.
- 수렴 반경을 벗어나면 급수의 근사 정확도가 크게 떨어질 수 있다.

---

## 주요 함수의 Maclaurin 전개 🧾

다음은 대표적인 함수들의 **Maclaurin 급수** 전개식이다.

| 함수 | 전개식 |
|------|--------|
| \( e^x \) | \( 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots \) |
| \( \sin x \) | \( x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots \) |
| \( \cos x \) | \( 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots \) |
| \( \ln(1 + x) \) | \( x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots \) (단, \(|x| < 1\)) |
| \( (1 + x)^k \) | \( 1 + kx + \frac{k(k-1)}{2!}x^2 + \cdots \) (단, \(|x| < 1\)) |

### 예시

```python
# sin(x)의 Maclaurin 급수 근사 (x=0.3, n=4)
def maclaurin_sin(x, n):
    return sum([(-1)**k * x**(2*k+1) / factorial(2*k+1) for k in range(n+1)])

print(f"sin(0.3) 근사값 (n=4): {maclaurin_sin(0.3, 4):.4f}")  # 출력: sin(0.3) 근사값 (n=4): 0.2955
```

### 주의사항

- 각 급수의 수렴 반경을 반드시 확인해야 하며, 일부 함수는 특정 구간 내에서만 급수가 수렴한다.
- 급수의 항을 많이 사용할수록 근사 정확도가 높아진다.